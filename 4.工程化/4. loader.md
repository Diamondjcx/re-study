# loader 是什么，有什么作用

处理任意类型的文件，并且将它们转换成一个让 webpack 可以处理的有效模块

```
webpack 的编译器
webpack默认只解析js和json。loader可以让webpack支持解析更多格式的文件
比如.css // .vue //.less // .sass // .jsx //.ts
一个loader只做一件事
```

# 常见的 loader

- css-loader：是将 css 转化为 js，转化为字符串插入到打包文件中，样式还没有生效。
- style-loader：借助 style-loader 使样式生效。可以在 head 插入一个 style 标签，然后将 css 从打包文件中提取出来，插入到 style 里面
- less-loader: 将 less 解析成相应的 css，webpack 和 less 进行沟通
- postcss-loader: 处理一些浏览器前缀

  ```
  安装postcss-loader autoprefix  新建文件进行配置

  处理css成ast抽象语法树，如何把抽象语法树准换成相应的css
  借助postcss的插件  autoprefixer  浏览器自动补全，css3加前缀
      overrideBrowserslist重写覆盖package.json中的浏览器版本
      还有别的插件：pxtorem  postcss-plugin-px2erm
  ```

- file-loader: 处理静态文件 .txt .md .png .pdf .word 第三方字体内容不需要加工，直接输出到打包文件
  ```
  不做处理，文件名直接是一坨，可以对其进行设置参数
  设置参数:options
  ```
- url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去
- source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试
- image-loader：加载并且压缩图⽚⽂件
- babel-loader：把 ES6 转换成 ES5
- eslint-loader：通过 ESLint 检查 JavaScript 代码

# vue-loader

vue-loader 的工作就是处理 vue 组件，正确解析各个部分 <template> <css> <script>

```js
// vue-loader descriptor
{
  customBlocks: [],
  errors: [],
  template: {
    attrs: {},
    content: "\n<div id="app">\n  <div class="title">{{msg}}</div>\n</div>\n",
    type: "template"
  },
  script: {
    attrs: {},
    content: "... export default {} ...",
    type: "script"
  },
  style: [{
    attrs: {
      lang: "scss"
    },
    content: "... #app {} ...",
    type: "style",
    lang: "scss"
  }],
}
```

解析到对应的 type，然后分别处理各个部分

```js
// template
let templateImport = `var render, staticRenderFns`;
let templateRequest;
if (descriptor.template) {
  const src = descriptor.template.src || resourcePath;
  const idQuery = `&id=${id}`;
  const scopedQuery = hasScoped ? `&scoped=true` : ``;
  const attrsQuery = attrsToQuery(descriptor.template.attrs);
  const query = `?vue&type=template${idQuery}${scopedQuery}${attrsQuery}${inheritQuery}`;
  const request = (templateRequest = stringifyRequest(src + query));
  templateImport = `import { render, staticRenderFns } from ${request}`;
}

// script
let scriptImport = `var script = {}`;
if (descriptor.script) {
  const src = descriptor.script.src || resourcePath;
  const attrsQuery = attrsToQuery(descriptor.script.attrs, "js");
  const query = `?vue&type=script${attrsQuery}${inheritQuery}`;
  const request = stringifyRequest(src + query);
  scriptImport = `import script from ${request}\n` + `export * from ${request}`; // support named exports
}

// styles
let stylesCode = ``;
if (descriptor.styles.length) {
  stylesCode = genStylesCode(
    loaderContext,
    descriptor.styles,
    id,
    resourcePath,
    stringifyRequest,
    needsHotReload,
    isServer || isShadow // needs explicit injection?
  );
}
```

针对不同的 type 分别构造一个 import 字符串

```js
templateImport = "import { render, staticRenderFns } from './App.vue?vue&type=template&id=7ba5bd90&'";

scriptImport = "import script from './App.vue?vue&type=script&lang=js&'
                export * from './App.vue?vue&type=script&lang=js&'";

stylesCode = "import style0 from './App.vue?vue&type=style&index=0&lang=scss&'";
```

```js
let code =
  `
${templateImport}
${scriptImport}
${stylesCode}`.trim() + `\n`;
code += `\nexport default component.exports`;
return code;
```

loader 会导出一个可执行的 node 模块，上面提到的 code 是会被 webpack 识别到然后执行的。

我们看到 code 里有三次的 import，import 的文件都是 App.vue，相当于又加载了一次触发这次 vue-loader 的那个 vue 文件。不同的是，这次加载是「带参」的，分别对应着 template / script / style 三种 type 的处理

webpack 在加载 vue 文件时，会调用 vue-loader 来处理 vue 文件，之后 return 一段可执行的 js 代码，其中会根据不同 type 分别 import 一次当前 vue 文件，并且将参数传递进去，这里的多次 import 也会被 vue-loader 拦截，然后在 vue-loader 内部根据不同参数进行处理（比如调用 style-loader）

# 写一个 loader

loader 本质是一个函数，但是不能使用箭头函数

loader 处理模块

resolveLoader 去哪里找 loader，进行拓展

```js
module.export = function (source) {
  // 传递的参数可以通过this获取 this.query
  // 一定要有返回值
  // return source.replace('webpack', this.query.name)

  // const result = source.replace('webpack', this.query.name)
  // 第一个参数error
  // 第二个参数返回值
  // 第三个参数source map 往下传递
  // this.callback(null, result)
  // 处理异步

  const callback = this.async();
  setTimeout(() => {
    const result = source.replace("webpack", this.query.name);

    callback(null, result);
  }, 2000);
};
```
