# webpack

## 基本概念

模块打包工具

从入口模块出发，识别出源码中的模块化导入语句，递归地找出入口文件的所有依赖，将入口和其所有的依赖打包到一个单独的文件中

1、参数解析
2、找到入口文件
3、调用 loader 编译文件
4、遍历 AST,收集依赖
5、生成 chunk
6、输出文件

- webpack 默认支持 js 模块、json 模块
- 支持 CommonJS、 Es module、 AMD 等模块类型

## 配置详解

/\*\*

- webpack 的基础配置
  \*/

```javascript
module.export = {
  entry: "./src/index.js", // 入口文件
  output: "./dist", // 输出结构
  mode: "production", // 打包环境
  module: {
    rules: [
      // loader模块处理
      {
        test: /\.css$/,
        use: "style=loader",
      },
    ],
  },
  plugins: [new HtmlWebpackPlugin()], // 插件配置
};
```

### 入口

指定 webpack 打包入口文件：Webpack 执行构建的第一步将从 entry 开始，可抽象成输入

```javascript
 //单⼊⼝ SPA，本质是个字符串
 entry:{
   main: './src/index.js'
 }
 // ==相当于简写===
 entry:"./src/index.js"
 //多⼊⼝ entry是个对象
 entry:{
   index:"./src/index.js",
   login:"./src/login.js"
 }
```

### 输出

path name

webpack 在哪里输出它所建的 bundle，如何命名这些文件

打包转换后的文件输出到磁盘位置输出结果，在 webpack 经过一系列处理并得出最终想要的代码后输出结果

```javascript
output: {
  filename: "bundle.js",//输出⽂件的名称
  path: path.resolve(__dirname, "dist")//输出⽂件到磁盘的⽬录，必须是绝对路径
},

  //多⼊⼝的处理
output: {
  filename: "[name][chunkhash:8].js",//利⽤占位符，⽂件名称不要重复
  path: path.resolve(__dirname, "dist")//输出⽂件到磁盘的⽬录，必须是绝对路径
},
```

### 模式

设置 mode 可以自动触发 webpack 内置的函数，达到优化的效果

用来指定当前的构建环境

- production
- development
- none
  开发阶段的开启会有利于热更新的处理，识别哪个模块变化
  生成阶段的开启会有帮助模块压缩，处理副作用等一些功能

### loader

webpack 只能理解 JavaScript 和 JSON 文件，loader 让 webpack 能够处理其他类型的文件，并将它们转换为有效模块。

特性：链式调用，链中的每个 loader 都将对资源进行转化，从上到下，从右到左。
链会逆序执行。第一个 loader 将其结果（被转换后的资源）传递给下一个 loader，依此类推。最后，webpack 期望链中的最后的 loader 返回 JavaScript。

处理任意类型的文件，并且将它们转换成一个让 webpack 可以处理的有效模块

模块解析，模块转换器，用于把模块原内容按照需求转换成新内容

webpack 是模块打包工具，而模块不仅仅是 js，还可以是 css，图片或者其他格式

但是 webpack 默认只知道如何处理 js 和 json 模块，那么其他格式的模块处理，和处理方式就需要 loader 了

常见的 loader

```
style-loader
css-loader
less-loader
sass-loader
ts-loader
babel-loader
file-loader
eslint-loader
...

```

### 插件 plugin

打包优化、资源管理、注入环境变量

### 模式 mode

通过选择 development, production 或 none 之中的一个，来设置 mode 参数，可以启用 webpack 内置在相应环境下的优化。

### chunk

代码块，一个 chunk 由多个模块组合而成，用户代码合并与分割

### modules

开发者将程序分解为功能离散的 chunk，称之为模块

webpack 模块

- ES2015 impport 语句
- CommonJS require() 语句
- AMD define 和 require 语句
- css/sass/less 文件中的 @import 语句。
- stylesheet url(...) 或者 HTML <img src=...> 文件中的图片链接。

webpack 支持的模块

- ECMAScript 模块
- CommonJS 模块
- AMD 模块
- Assets
- WebAssembly 模块

模块，在 webpack 里一切皆模块，一个模块对应着一个文件，会从配置的 entry 开始递归找出所有依赖的模块

当 webpack 处理到不认识的模块时，需要在 webpack 中的 module 处进行配置，当检测到是什么格式的模块，使用什么 loader 来处理

```javascript
module: {
  rules: [
    {
      test: /\.xxx$/, // 指定匹配规则
      use: {
        loader: "xxx-loader", // 指定使用的loader
      },
    },
  ];
}
```

### 依赖图(dependency graph)

当 webpack 处理应用程序时，它会根据命令行参数中或配置文件中定义的模块列表开始处理。 从 入口 开始，webpack 会递归的构建一个*依赖关系图*，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为少量的 bundle —— 通常只有一个 —— 可由浏览器加载

### target

JavaScript 既可以编写服务器代码也可以编写浏览器代码，所以 webpack 提供了多种部署 target

### manifest

webpack 的 runtime 和 manifest，管理所有模块的交互

runtime，以及伴随的 manifest 数据，主要是指：在浏览器运行过程中，webpack 用来连接模块化应用程序 所需的所有代码。
包含：模块交互时，连接模块所需的加载和解析逻辑
已经加载到浏览器中的链接模块逻辑以及尚未加载模块的延迟加载逻辑

manifest: 管理所有所需模块之间的交互

### 模块热替换(hot module replacement)

应用程序运行过程中，替换、添加或删除模块，而无需重新加载整个页面

## zhuawa 分享

### 1. Wbpack 中的 Module 是指什么？

webpack 前端模块体系

webpack 支持 ESModule， CommonJS, AMD, Assests.(iamge, font, video, audio, json)

1. ESM

关键字 export， 允许将 ESM 中内容暴露给其他模块

关键字 import 引入文件

```js
import { aa } from "./a.js";

export { bb };
```

// package.json

type module -> ESM
type commonjs -> CommonJS

2. CommonJS

module.exports, 允许将 CommonJS 中的内容暴露给其他模块

require

### 所以 webpack modules， 如何表达自己的各种依赖关系？

- ESM import 语句
- CommonJS require
- AMD define require
- css/sass/less @import

### 我们常说的 chunk 和 bundle 的区别是什么？（import！！！）

1. Chunk

Chunk 是 webpack 打包过程中 Modules 的集合，是（打包过程中）的概念

Webpack 的打包是从一个入口模块开始，入口模块引用其他模块，其他模块引用其他模块.....

webpack 通过引用关系逐个打包模块，这些 module 就形成了一个 chunk

如果有多个入口模块，可能会产出多条打包路径，每条路径都会形成一个 chunk

2. Bundle

是我们最终输出的一个或者多个打包好的文件

3. Chunk 和 Bundle 的关系是什么？

大多数情况下，一个 chunk 会生产一个 bundle，但是也有例外

chunk 是过程 Bundle 是结果

但是如果加了 sourcemap，一个 entry 一个 chunk 对应两个 bundle

Chunk 是过程中代码块，Bundle 是打包结果输出的代码块，Chunk 在构建完成就呈现为 Bundle

4. Split Chunk

不同文件进行分割，第三方包分开打包

```javascript
optimization: {
  runtimeChunk: "single";
}
```

5. 这段配置会产生几个 chunk

这段代码会输出几个 chunk 和一个 module
1、entry index
2、entry other
3、runtimeChunk:'single'
4、splitChunks: common
5、splitChunks: vendor

commons:{
chunks:'initial',
minChunks:2 // 如果有 2 个文件都引用了，要单独打包
}

### Plugin 和 Loader 分别是做什么的？ 怎么工作的？

1、Loader

模块转换器，将非 js 模块转化为 webpack 能识别的 js 模块

本质上，webpack loader 将所有类型的文件，转换为应用程序的**_依赖图_**可以直接引用模块

2、Plugin

扩展插件，webpack 运行的各个阶段，都会广播对应的时间，插件去监听对应的事件。

3、Compiler

对象，包含了 webpack 环境的所有配置信息，包括 options loader，plugins webpack 启动的时候实例化，它在全局是唯一的，可以把它理解为 webpack 的实例

4、Compliation

包含了当前的模块资源，编译生成资源

webpack 在开发模式下运行的时候，每当检测到一个文件变化，就会创建一次新的 Comliation

### 能简单描述一下 webpack 的打包过程吗？

1. 初始化参数：shell webpack.config.js
2. 开始编译：初始化一个 Comiler 对象，加载所有的配置，开始执行编译
3. 确定入口：根据 entry 中的配置，找出所有的入口文件
4. 编译模块：从入口文件开始，调用所有的 laoder，再去递归的找依赖
5. 完成模块编译：得到每个模块被翻译后的最终内容以及他们之间的依赖关系
6. 输出资源：根据得到依赖关系，组装成一个个包含多个 module 的 chunk
7. 输出完成：根据配置，确定要输出的文件
