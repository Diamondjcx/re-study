# 状态码

# GET 和 POST 的区别

知乎中优秀的回答：https://www.zhihu.com/question/28586791

结论：协议是人定的。两者没有实质性的区别

## 浏览器的 GET 和 POST

特指的是非 Ajax 的 HTTP 请求，从浏览器和 HTTP 诞生就一直使用的 HTTP 协议中的 GET/POST。
浏览器用 GET 请求来获取一个 html 页面/图片/css/js 等资源；用 POST 来提交一个<form>表单，并得到一个结果的网页。

GET

`GET`方法请求一个指定资源的表示形式，使用 GET 的请求应该只被用于获取数据

- 读取一个资源。GET 一个 html 文件，反复读取不应该对访问的数据产生副作用---幂等

- GET 是请求数据，可以对数据进行缓存（浏览器、nginx、server 端）

- 浏览器发送 GET 请求时，会在 url 后面带一些参数（浏览器直接发出的 GET 请求只能是通过 url--浏览器中直接输入或者是点击 a 标签

POST

`POST`方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或**副作用**

本质上都是`TCP`链接，并无差别

但是由于`HTTP`的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别

- 点击 submit 元素，会发送一个 post 请求，让服务端去做一件事，反复提交，会产生副作用---非幂等

- 不幂等意味着不可以执行多次，因此就不可以缓存，也不可以保存为标签（点一次，下一次单，好恐怖

- 浏览器中 POST 请求都来自表单提交。每次提交，被浏览器用编码到 HTTP 请求的 body 里（浏览器在 POST 一个表单时，url 上也可以带参数，只要<form action="url" >里的 url 带 querystring 就行。只不过表单里面的那些用<input> 等标签经过用户操作产生的数据都在会在 body 里。
- application/x-www-form-urlencoded 用来传输简单的数据：key1=value1&key2=value2
- multipart/form-data:传文件,如果采用另外一种方式，对二进制文件处理很低效

## 接口中的 GET 和 POST

这里指的是浏览器的 Ajax api，没有浏览器那么多限制，但是太自由也不好，所以会出现相应的一些标准，比如 REST
REST 中 GET 和 POST 不是随便用的

- GET】 + 【资源定位符】被专用于获取资源或者资源列表

```javascript
GET http://foo.com/books          获取书籍列表
GET http://foo.com/books/:bookId  根据bookId获取一本具体的书
```

幂等--可缓存

- 【POST】+ 【资源定位符】则用于“创建一个资源”

## 关于安全性

从攻击的角度，无论是 GET 还是 POST 都不够安全
因为 HTTP 本身是明文协议。每个 HTTP 请求和返回的每个 byte 都会在网络上明文传播，不管是 url,header 还是 body

避免：客户端到服务器端端加密。
通行做法：https--用 SSL 协议协商出的密钥加密明文的 http 数据。

## 关于编码

所谓编码确切地说应该是 http 中的 url 用什么编码，body 用什么编码

url:字符编码（大部分是 utf8）+Percent Encode 翻译为真正的 url 发给服务器
body：Content-Type 定义请求 body 的格式和字符

## 浏览器的 POST 需要发送两个请求吗？

结论：发一次还是发 N 次，客户端可以很灵活的决定，不管怎么发都是符合 HTTP 协议的。
因此应该视为这种优化是一种实现细节。

先发送请求头给服务器，让服务器进行校验，如果通过了，客户端再把剩下的数据发给服务器，拒绝，回复个错误，交互终止。避免浪费贷款传请求体。

### 到底什么算请求体

HTTP 协议角度，"请求头"就是 Method + URL(含 querystring) + Headers 再后面都是请求体

对于 HTTP 代理

- 支持转发规则，比如 nginx 先要解析请求头，拿到 URL 和 Header 才能决定怎么做（转发 proxy_pass，重定向 redirect，rewrite 后重新判断……）
- 需要用请求头的信息记录 log。尽管请求体里的数据也可以记录，但一般只记录请求头的部分数据。
- 如果代理规则不涉及到请求体，那么请求体就可以不用从内核态的 page cache 复制一份到用户态了，可以直接 zero copy 转发。这对于上传文件的场景极为有效。……

对于 HTTP 服务器

- 可以通过请求头进行 ACL 控制，比如看看 Athorization 头里的数据是否能让认证通过
- 可以做一些拦截，比如看到 Content-Length 里的数太大，或者 Content-Type 自己不支持，或者 Accept 要求的格式自己无法处理，就直接返回失败了。
- 如果 body 的数据很大，利用 Stream API，可以方便支持一块一块的处理数据，而不是一次性全部读取出来再操作，以至于占用大量内存。

## 关于 URL 的长度

GET 数据有长度限制：其实是指”URL 的长度限制“
HTTP 协议本身对 URL 没有任何限制，这些限制是客户端/浏览器和服务端共同决定的

如果 url 过长，会分配更多的内存，并发量很高，可能会挤爆服务器；影响搜索引擎的的爬虫

## 二、区别

从`w3schools`得到的标准答案的区别如下：

- GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
- GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。
- GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
- GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
- GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。
- GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。
- 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。
- GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。
- GET 参数通过 URL 传递，POST 放在 Request body 中

### 参数位置

貌似从上面看到`GET`与`POST`请求区别非常大，但两者实质并没有区别

无论 `GET `还是 `POST`，用的都是同一个传输层协议，所以在传输上没有区别

当不携带参数的时候，两者最大的区别为第一行方法名不同

> POST /uri HTTP/1.1 \r\n
>
> GET /uri HTTP/1.1 \r\n

当携带参数的时候，我们都知道`GET`请求是放在`url`中，`POST`则放在`body`中

`GET` 方法简约版报文是这样的

```
GET /index.html?name=qiming.c&age=22 HTTP/1.1
Host: localhost
```

`POST `方法简约版报文是这样的

```
POST /index.html HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded

name=qiming.c&age=22
```

注意：这里只是约定，并不属于`HTTP`规范，相反的，我们可以在`POST`请求中`url`中写入参数，或者`GET`请求中的`body`携带参数

### 参数长度

`HTTP `协议没有`Body`和 `URL` 的长度限制，对 `URL `限制的大多是浏览器和服务器的原因

`IE`对`URL`长度的限制是 2083 字节(2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持

这里限制的是整个`URL`长度，而不仅仅是参数值的长度

服务器处理长` URL` 要消耗比较多的资源，为了性能和安全考虑，会给 `URL` 长度加限制

### 安全

`POST `比` GET` 安全，因为数据在地址栏上不可见

然而，从传输的角度来说，他们都是不安全的，因为` HTTP` 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文

只有使用`HTTPS`才能加密安全

### 数据包

对于`GET`方式的请求，浏览器会把`http header`和`data`一并发送出去，服务器响应 200（返回数据）

对于`POST`，浏览器先发送`header`，服务器响应 100 `continue`，浏览器再发送`data`，服务器响应 200 ok

并不是所有浏览器都会在`POST`中发送两次包，`Firefox`就只发送一次

# 常见的状态码

特定的 HTTP 请求是否已经完成

响应：信息响应（100-199）、成功响应（200-299）、重定向（300-399）、客户端错误（400-499）、服务端错误（500-599）

2\*\* 成功：表明请求被正常处理了
200 ok 表示从客户端发来的请求在服务器被正确处理
204 No content 表示请求成功，但响应报文不含实体的主体部分
206 Partial Content 进行范围请求成功

3\*\* 重定向（表明浏览器需要执行特殊处理
301 moved permanently,永久性重定向，表示资源已被分配了新的 URL
302 found 临时性重定型，表示资源临时被分配了新的 URL
303 see other 表示资源存在着另一个 URL，应使用 GET 方法获取资源
304 not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）
307 temporary redirect 临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

4XX 客户端错误 400bad request，请求报文存在语法错误
401unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
403forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述
404not found，表示在服务器上没有找到请求的资源

5XX 服务器错误 500internal sever error，表示服务器端在执行请求时发生了错误
501Not Implemented，表示服务器不支持当前请求所需要的某个功能
503service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

你所知道的 3xx 状态码：https://jelly.jd.com/article/6006b1035b6c6a01506c8791

# 面试官：说说 HTTP 常见的状态码有哪些，适用场景？

![](https://static.vue-js.com/038831d0-bbc9-11eb-ab90-d9ae814b240d.png)

## 一、是什么

HTTP 状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的 3 位数字代码

它由 RFC 2616 规范定义的，并得到 `RFC 2518`、`RFC 2817`、`RFC 2295`、`RFC 2774`与 `RFC 4918`等规范扩展

简单来讲，`http`状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态

## 二、分类

状态码第一位数字决定了不同的响应状态，有如下：

- 1 表示消息
- 2 表示成功
- 3 表示重定向
- 4 表示请求错误
- 5 表示服务器错误

### 1xx

代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束

常见的有：

- 100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
- 101：服务器根据客户端的请求切换协议，主要用于 websocket 或 http2 升级

### 2xx

代表请求已成功被服务器接收、理解、并接受

常见的有：

- 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
- 201（已创建）：请求成功并且服务器创建了新的资源

- 202（已创建）：服务器已经接收请求，但尚未处理
- 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源
- 204（无内容）：服务器成功处理请求，但没有返回任何内容
- 205（重置内容）：服务器成功处理请求，但没有返回任何内容
- 206（部分内容）：服务器成功处理了部分请求

### 3xx

表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向

常见的有：

- 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
- 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
- 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
- 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码

- 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
- 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

### 4xx

代表了客户端看起来可能发生了错误，妨碍了服务器的处理

常见的有：

- 400（错误请求）： 服务器不理解请求的语法
- 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403（禁止）： 服务器拒绝请求
- 404（未找到）： 服务器找不到请求的网页
- 405（方法禁用）： 禁用请求中指定的方法
- 406（不接受）： 无法使用请求的内容特性响应请求的网页
- 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
- 408（请求超时）： 服务器等候请求时发生超时

### 5xx

表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生

常见的有：

- 500（服务器内部错误）：服务器遇到错误，无法完成请求
- 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
- 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
- 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
- 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
- 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本

## 三、适用场景

下面给出一些状态码的适用场景：

- 100：客户端在发送 POST 数据给服务器前，征询服务器情况，看服务器是否处理 POST 的数据，如果不处理，客户端则不上传 POST 数据，如果处理，则 POST 上传数据。常用于 POST 大数据传输

- 206：一般用来做断点续传，或者是视频文件等大文件的加载

- 301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用 301 就重定向到新的域名

- 302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面
- 304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分
- 400：参数有误，请求无法被服务器识别
- 403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网 IP 才能访问的时候则返回
- 404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时
- 503：服务器停机维护时，主动用 503 响应请求或 nginx 设置限速，超过限速，会返回 503

- 504：网关超时

## 参考文献

- https://zh.wikipedia.org/wiki/HTTP状态码
- https://kebingzao.com/2018/10/05/http-status-code/

# HTTP keep-alive 长连接

是什么？
客户端和服务端的一个约定，开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接受完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接

解决了什么问题？
保持长连接，可以省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间。

带来新的问题
连接一直不关闭，随着客户端越来越多，server 扛不住

解决新的问题
采取策略，如关闭一些长时间没有读写时间发生的连接。限制每个客户端的最大长连接数

# HTTP1.0\HTTP1.1\HTTP2.0

## 一、HTTP1.0

`HTTP`协议的第二个版本，第一个在通讯中指定版本号的 HTTP 协议版本

`HTTP 1.0` 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个`TCP`连接

服务器完成请求处理后立即断开`TCP`连接，服务器不跟踪每个客户也不记录过去的请求

简单来讲，每次与服务器交互，都需要新开一个连接

![](https://static.vue-js.com/efff4da0-b93a-11eb-85f6-6fac77c0c9b3.png)

例如，解析`html`文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接

最终导致，一个`html`文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接

这种形式明显造成了性能上的缺陷

如果需要建立长连接，需要设置一个非标准的 Connection 字段 `Connection: keep-alive`

## 二、HTTP1.1

在`HTTP1.1`中，默认支持长连接（`Connection: keep-alive`），即在一个 TCP 连接上可以传送多个`HTTP`请求和响应，减少了建立和关闭连接的消耗和延迟

建立一次连接，多次请求均由这个连接完成

![](https://static.vue-js.com/22db2b90-b93b-11eb-ab90-d9ae814b240d.png)

这样，在加载`html`文件的时候，文件中多个请求和响应就可以在一个连接中传输

同时，`HTTP 1.1`还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间

同时，`HTTP1.1`在`HTTP1.0`的基础上，增加更多的请求头和响应头来完善的功能，如下：

- 引入了更多的缓存控制策略，如 If-Unmodified-Since, If-Match, If-None-Match 等缓存头来控制缓存策略
- 引入 range，允许值请求资源某个部分
- 引入 host，实现了在一台 WEB 服务器上可以在同一个 IP 地址和端口号上使用不同的主机名来创建多个虚拟 WEB 站点

并且还添加了其他的请求方法：`put`、`delete`、`options`...

### 缺陷

- 协议规定客户端对同一域的并发连接最多只能 2 个，但是现代网页平均一个页面需要加载 40 个资源
- 线头阻塞问题：同一个连接中的请求，需要一个接一个串行发送和接收
- 基于文本协议，请求和响应的头信息非常大，并且无法压缩
- 不能控制响应优先级，必须按照请求顺序响应
- 只能单向请求，客户端请求什么，服务器只能返回什么

## 三、HTTP2.0

而`HTTP2.0`在相比之前版本，性能上有很大的提升，如添加了一个特性：

- 多路复用
- 二进制分帧
- 首部压缩
- 服务器推送

- 传输内容使用二进制协议
- 使用帧作为最小传输单位
- 多路复用
- 头压缩
- 服务器推送
- 优先级与依赖性
- 可重置
- 流量控制
- 基于 HTTPS 来实现 HTTP2

### 多路复用

`HTTP/2` 复用`TCP`连接，在一个连接里，客户端和浏览器都可以**同时**发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”

![](https://static.vue-js.com/313f1980-b93b-11eb-85f6-6fac77c0c9b3.png)

上图中，可以看到第四步中`css`、`js`资源是同时发送到服务端

### 二进制分帧

帧是`HTTP2`通信中最小单位信息

`HTTP/2` 采用二进制格式传输数据，而非 `HTTP 1.x `的文本格式，解析起来更高效

将请求和响应数据分割为更小的帧，并且它们采用二进制编码

`HTTP2 `中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流

每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件

### 首部压缩

`HTTP/2`在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送

首部表在`HTTP/2`的连接存续期内始终存在，由客户端和服务器共同渐进地更新

例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销

![](https://static.vue-js.com/3c536740-b93b-11eb-ab90-d9ae814b240d.png)

### 服务器推送

`HTTP2`引入服务器推送，允许服务端推送资源给客户端

服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源

免得客户端再次创建连接发送请求到服务器端获取

这种方式非常合适加载静态资源

![](https://static.vue-js.com/47130550-b93b-11eb-85f6-6fac77c0c9b3.png)

## 四、http3.0

HTTP3 QUIC 协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。

QUIC 基于 UDP

- 实现类似 TCP 的流量控制、传输可靠性
- 实现了快速握手功能
- 继承了 TCP 加密功能
- 多路复用，彻底解决 TCP 中队头阻塞问题

## 四、总结

HTTP1.0：

- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接【每次请求需建立 tcp 连接】

HTTP1.1：

- 引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用【持久连接、请求复用】
- 在同一个 TCP 连接里面，客户端可以同时发送多个请求【同时发送多个】
- 虽然允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着【排队】
- 新增了一些请求方法
- 新增了一些请求头和响应头

HTTP2.0：

- 采用二进制格式而非文本格式【二进制传输】
- 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行【多路复用、并行】
- 使用报头压缩，降低开销【压缩，降低开销】
- 服务器推送【服务器推送】

# 什么是 HTTP? HTTP 和 HTTPS 的区别?

## 一、HTTP

`HTTP` (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范

![](https://static.vue-js.com/fda119b0-b20b-11eb-85f6-6fac77c0c9b3.png)

在计算机和网络世界有，存在不同的协议，如广播协议、寻址协议、路由协议等等......

而`HTTP`是一个传输协议，即将数据由 A 传到 B 或将 B 传输到 A，并且 A 与 B 之间能够存放很多第三方，如： A<=>X<=>Y<=>Z<=>B

传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如 HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别

在实际应用中，`HTTP`常被用于在`Web`浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密

特点如下：

- 支持客户/服务器模式

- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快
- 灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
- 无状态：HTTP 协议无法根据之前的状态进行本次的请求处理

## 二、HTTPS

在上述介绍`HTTP`中，了解到`HTTP`传递信息是以明文的形式发送内容，这并不安全。而`HTTPS`出现正是为了解决`HTTP`不安全的特性

为了保证这些隐私数据能加密传输，让`HTTP`运行安全的`SSL/TLS`协议上，即 HTTPS = HTTP + SSL/TLS，通过 `SSL`证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密

`SSL` 协议位于` TCP/IP` 协议与各种应用层协议之间，浏览器和服务器在使用 `SSL` 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持

![](https://static.vue-js.com/078c50c0-b20c-11eb-ab90-d9ae814b240d.png)

流程图如下所示：

![](https://static.vue-js.com/0e409fc0-b20c-11eb-85f6-6fac77c0c9b3.png)

- 首先客户端通过 URL 访问服务器建立 SSL 连接
- 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
- 客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
- 服务器利用自己的私钥解密出会话密钥
- 服务器利用会话密钥加密与客户端之间的通信

## 三、区别

- HTTPS 是 HTTP 协议的安全版本，HTTP 协议的数据传输是明文的，是不安全的，HTTPS 使用了 SSL/TLS 协议进行了加密处理，相对更安全
- HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP 是 80，HTTPS 是 443
- HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
- HTTPS 需要 SSL，SSL 证书需要钱，功能越强大的证书费用越高

# 面试官：说说 HTTP 常见的请求头有哪些? 作用？

![](https://static.vue-js.com/964abb00-bc69-11eb-85f6-6fac77c0c9b3.png)

## 一、是什么

HTTP 头字段（HTTP header fields）,是指在超文本传输协议（HTTP）的请求和响应消息中的消息头部分

它们定义了一个超文本传输协议事务中的操作参数

HTTP 头部字段可以自己根据需要定义，因此可能在 `Web `服务器和浏览器上发现非标准的头字段

下面是一个`HTTP`请求的请求头：

```http
GET /home.html HTTP/1.1
Host: developer.mozilla.org
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/testpage.html
Connection: keep-alive
Upgrade-Insecure-Requests: 1
If-Modified-Since: Mon, 18 Jul 2016 02:36:04 GMT
If-None-Match: "c561c68d0ba92bbeb8b0fff2a9199f722e3a621a"
Cache-Control: max-age=0
```

## 二、分类

常见的请求字段如下表所示：

| 字段名            | 说明                                                                                                                                                                          | 示例                                                                             |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| Accept            | 能够接受的回应内容类型（Content-Types）                                                                                                                                       | Accept: text/plain                                                               |
| Accept-Charset    | 能够接受的字符集                                                                                                                                                              | Accept-Charset: utf-8                                                            |
| Accept-Encoding   | 能够接受的编码方式列表                                                                                                                                                        | Accept-Encoding: gzip, deflate                                                   |
| Accept-Language   | 能够接受的回应内容的自然语言列表                                                                                                                                              | Accept-Language: en-US                                                           |
| Authorization     | 用于超文本传输协议的认证的认证信息                                                                                                                                            | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==                                |
| Cache-Control     | 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令                                                                                                                 | Cache-Control: no-cache                                                          |
| Connection        | 该浏览器想要优先使用的连接类型                                                                                                                                                | Connection: keep-alive Connection: Upgrade                                       |
| Cookie            | 服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议 Cookie                                                                                                           | Cookie: $Version=1; Skin=new;                                                    |
| Content-Length    | 以 八位字节数组 （8 位的字节）表示的请求体的长度                                                                                                                              | Content-Length: 348                                                              |
| Content-Type      | 请求体的 多媒体类型                                                                                                                                                           | Content-Type: application/x-www-form-urlencoded                                  |
| Date              | 发送该消息的日期和时间                                                                                                                                                        | Date: Tue, 15 Nov 1994 08:12:31 GMT                                              |
| Expect            | 表明客户端要求服务器做出特定的行为                                                                                                                                            | Expect: 100-continue                                                             |
| Host              | 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号                                                                                                             | Host: en.wikipedia.org:80 Host: en.wikipedia.org                                 |
| If-Match          | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源 | If-Match: "737060cd8c284d8af7ad3082f209582d"                                     |
| If-Modified-Since | 允许在对应的内容未被修改的情况下返回 304 未修改                                                                                                                               | If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT                                 |
| If-None-Match     | 允许在对应的内容未被修改的情况下返回 304 未修改                                                                                                                               | If-None-Match: "737060cd8c284d8af7ad3082f209582d"                                |
| If-Range          | 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体                                                                                            | If-Range: "737060cd8c284d8af7ad3082f209582d"                                     |
| Range             | 仅请求某个实体的一部分                                                                                                                                                        | Range: bytes=500-999                                                             |
| User-Agent        | 浏览器的浏览器身份标识字符串                                                                                                                                                  | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |
| Origin            | 发起一个针对 跨来源资源共享 的请求                                                                                                                                            | Origin: http://www.example-social-network.com                                    |

## 三、使用场景

通过配合请求头和响应头，可以满足一些场景的功能实现：

### 协商缓存

协商缓存是利用的是`【Last-Modified，If-Modified-Since】`和`【ETag、If-None-Match】`这两对请求头响应头来管理的

`Last-Modified` 表示本地文件最后修改日期，浏览器会在 request header 加上`If-Modified-Since`（上次返回的`Last-Modified`的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来

`Etag`就像一个指纹，资源变化都会导致`ETag`变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的

`If-None-Match`的 header 会将上次返回的`Etag`发送给服务器，询问该资源的`Etag`是否有更新，有变动就会发送新的资源回来

而强制缓存不需要发送请求到服务端，根据请求头`expires`和`cache-control`判断是否命中强缓存

强制缓存与协商缓存的流程图如下所示：

![](https://static.vue-js.com/a4065b00-bc69-11eb-85f6-6fac77c0c9b3.png)

### 会话状态

`cookie`，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据，通过响应头`set-cookie`决定

作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 `Cookie `有效期、安全性、使用范围的可选属性组成

`Cookie` 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等

## 参考文献

- https://zh.wikipedia.org/wiki/HTTP头字段
- https://github.com/amandakelake/blog/issues/41
