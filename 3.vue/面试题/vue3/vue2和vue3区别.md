痛点：

1. 随着功能增长，复杂组件的代码越来越多 越难以维护
2. 多个组件提取和复用逻辑也不够友好
3. 类型推断不够友好
4. bundle 时间久

特性：

1. 更小

   1. 移除不常用的 api
   2. 引入 tree-shaking，仅打包需要的，没有用到的筛下去，打包体积变小了。任何一个函数 ref computed 在用到的时候再打包

2. 更快

   1. diff 算法优化
      静态标记，会发生变化的地方增加 flag 标记，下次发生变化时直接找该地方进行比较
   2. 静态提升
      对于不参与更新的元素，静态提升，只创建一次，在渲染时直接复用，免去重复的创建节点
   3. 预字符串化
      预字符串化是基于静态提升的一种优化策略。静态提升的虚拟节点或虚拟节点树本身是静态的，将这些静态节点序列化为字符串，并生成一个 static 类型的 VNode
   4. 缓存内联事件处理函数
      将处理函数缓存，当渲染函数重新执行并创建新的虚拟 DOM 树时，会优先读取缓存中的事件处理函数，避免不必要的更新，
   5. v-once 实现对虚拟 DOM 的缓存
      缓存全部或部分虚拟节点，能够避免组件更新时重新创建虚拟 DOM 带来的性能开销，也可避免无用的 Diff 操作

3. 更友好
   composition API

   1. 原 vue2 采用 OptionsAPI 用户提供 data、props、methods、computed、watch 等属性，用户编写复杂业务逻辑会出现反复横跳问题）
   2. vue2 所有属性都通过 this 访问，存在指向明确问题
   3. vue2 中很多未使用的方法或属性依旧会被打包，并且所有全局 API 都在 Vue 对象上公开。CompositionAPI 对 tree-shaking 更加友好，代码也更容易压缩。
   4. 组件逻辑共享问题，Vue2 采用 mixins 实现组件之间的逻辑共享：但是会有数据来源不明确，命名冲突等问题。Vue3 采用 CompositionAP1 提取公共逻辑非常方便

4. 其他方面
   1. 数据劫持优化
      1. 在`vue2`中，数据劫持是通过`Object.defineProperty `，这个 API 有一些缺陷，并不能检测对象属性的添加和删除，用$set,$delete 方法
      2. vue2 遍历对每个属性进行劫持监听的，在面对嵌套层级比较深的情况下，存在性能问题
      3. 监听数组浪费性能，对数组进行重写
      4. proxy 直接劫持整个对象，并返回一个新对象，只操作新的对象达到响应式目的
      5. proxy 可以直接监听数组的变化
      6. 可以监听其他数据类型变化 symbol
   2. 源码管理
      1. `vue3`整个源码是通过 `monorepo `的方式维护的，根据功能将不同的模块拆分到`packages `目录下面不同的子目录中
      2. `package`（比如 `reactivity` 响应式库）是可以独立于 `Vue` 使用的，这样用户如果只想使用 `Vue3 `的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 `Vue`
   3. 使用 typescript 编写，提供了更好的类型检查，能支持复杂的类型推导
