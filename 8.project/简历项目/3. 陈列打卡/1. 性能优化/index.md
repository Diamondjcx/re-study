# 性能定义

1. 减少整体加载时间（更快打开网页）
2. 使网站尽快可用（比如文本框渲染出来了，但是不可用）
3. 平滑和交互性(css 替代 js 动画，减少 U!重绘）
4. 感知表现（加载进度条，loading)

# 如何进行？

了解性能指标--多快才算快？
专业工具可量化评估
立足于网站页面响应的生命周期，分析出造成较差性能表现的原因
技术改造，可行性分析等具体优化实施
迭代优化

# 性能指标

## RAIL 性能模型 (request\animation\ldle\load)

响应：尽可能快速响应用户
动画：一帧 16ms 进行渲染
空闲：任务划分到执行时间小于 50ms 的片段
加载：小于 1s 加载完成网站，并可以进行用户交互

## 基于用户体验的性能指标

FCP：首次绘制来自 DOM 的内容的时间，内容必须是文本、图片（背景图）、非白色的 canvas 或 svg，也包括带有正在加载中的 web 字体的文本

LCP：最大内容绘制(随着网页的加载 LCP 一直变化的，最大的内容)

FID: first input delay 首次输入延迟

    1. 打开页面 东西看见了 但是不能进行交互，完全渲染完才可以进行交互
    2. 浏览器的主线程正在忙于其他事情，所以不能响应用户
    3. 表单元素：输入框、文本框\下拉框\a 链接

TTI: Time to Interactive 完全可达到交互状态

Total Block Time (TBT） 总阻塞时间 超出 50ms 的时间的总和

Cumulative Layout Shift (CLS)布局抖动，本来有一张图片 瞬间变成了其他内容

## Web Vitals

LCP
FID
CLS

## 其它性能指标

# 性能测试

使用灯塔 Lighthouse 测试性能

    检测得分
    性能指标
    优化建议
    诊断结果
    已通过的性能

使用 WebPageTest 测试性能：在线
使用 Chrome DevTools 测试性能
性能测量 APIs
性能监控

# 前端页面生命周期

(1）浏览器接收到 URL，到网络请求线程的开启。
(2）一个完整的 HTTP 请求并的发出。
(3) 服务器接收到请求并转到具体的处理后台。
(4）前后台之间的 HTTP 交互和涉及的缓存机制。
(5) 浏览器接收到数据包后的关键渲染路径。
(6) JS 引擎的解析过程。

## 网络请求线程开启

### 进程与线程

qq 和 微信 两个进程，一个进程中多个线程

只要某个线程执行出错，将会导致整个进程崩溃

进程和进程之间相互隔离。互相不影响，有一个崩溃不会影响其他进程，每个进程只能访问自己的资源，ipc 进行进程通信

进程占用的资源会在关闭后回收，某个线程内存泄漏，进程退出时，相关内存资源也会被回收

线程之间可以共享所属进程的数据

### 单进程浏览器

单进程多线程，一个线程崩溃，整个浏览器死掉

### 多进程浏览器

多进程，很少崩溃

浏览器主进程

GPU 进程

插件进程

网络进程

渲染进程，多线程，每个标签窗口页开辟一个独立的渲染进程

    JS引擎线程
    GUI渲染宣称
    事件触发线程
    定时触发器线程
    异步HTTP请求线程

## 建立 HTTP 请求

### DNS 解析

浏览器缓存
系统自身 DNS 缓存
hosts 文件
本地域名服务器
根域名服务器
COM 顶级域名服务器
权限域名服务器

### 网络模型

TCP/IP
应用层
传输层
网络层
数据链路层

OSI
应用层
表示层
会话层
传输层
网络层
数据链路层
物理层

### TCP 连接

三次握手
“3 次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。

客户端---服务端：先发消息，服务端是否能收到消息呢
服务端----客户端：服务端回应客户端一个消息，客户端非常确认给服务端发的消息，服务端收到了（客户端确认）
客户端----服务端：客户端回服务端消息，服务端确
消息，客户端收到了（服务端确认）

四次挥手
客户端发送断开请求的消息
服务端---客户端 收到了断开的请求 不再接受客户端的消息
服务端---客户端 没有消息传送了 断开吧
客户端---服务端 确认断开

## 前后端的交互

反向代理服务器
后端处理流程
HTTP 相关协议特性
浏览器缓存

## 关键渲染路径

浏览器会解析 html 和 css 文件，来构建 DOM(文档对象模型)和 CSSOM（层叠样式表对象模型） renderTree

构建对象模型
构建 CSSOM
渲染绘制

    （1）从所生成 DOM 树的根节点开始向下遍历每个子节点，忽略所有不
    可见的节点（脚本标记不可见、CSS 隐藏不可见），因为不可见的节点
    不会出现在渲染树中。
    (2)在 CSSOM 中为每个可见的子节点找到对应的规则并应用。
    （3）布局阶段，根据所得到的渲染树，计算它们在设备视图中的具体位
    置和大小，这一步输出的是一个“盒模型”。
    (4) 绘制阶段，将每个节点的具体绘制方式转化为屏幕上的实际像素。

# 优化

## 请求响应优化

### DNS 解析

1. 减少 DNS 查找(减少域名，至少两个但不超过四个域名，减少 DNS 查找)
2. dns-prefetch

   1. ```JS
      <link rel- "dns-prefetch" href= "https://fonts.Boof“ />
      ```

   2. 尝试在请求资源之前解析域名，减少用户的等待时间，域名解析和内容载入是串行的网络操作

### HTTP 长连接

短连接：每进行一次通信，就要断开 tcp 链接

长连接：1.1 持久连接

管道机制：1.1 同一个 tcp 链接，客户端可以并发的发送请求，但是响应不是并发，串行
Content-Length 字段：多个响应区分请求

分块传输编码：需要拿长度，费时间，通过流传输分块传输

长连接的缺点：1.1 多个请求，但是响应是串行的，处理宗一个诘求才能进行下一个请求，会造成堵塞，队头阻塞

1.1 基于文本协议传输 请求和响应都很大 且无法压缩

### HTTP2

http1.1 文本协议传输 二进制协议
多路复用(并行请求 并行响应 不用按照顺序。解决队头堵塞)
数据流(请求和响应是如何对应起来的)
头信息压缩
服务器推送：静态资源主动推送

### HTTP3

### 避免重定向

### 压缩传输的数据资源

### HTTP 缓存

强制缓存（无需和服务端通信）

1. expires：过期时间(客户端时间和服务端时间可能不同步)
2. cache-control：max-age =31536000 Cache-Control：多久过期

协商缓存(向服务端发送请求)

1.  last-modified 更新时间(文件名改成 03 再改回来，没改内容，缓存失效)
    告诉客户端该资源要使用协商缓存
    客户端使用缓存数据之前问一下服务器缓存有效吗

    服务端：

         有效：返回 304，客户端使用本地缓存资源
         无效：直接返回新的资源数据，客产端直接使用

    res. setHeader('Cache-Control,'no-cache”)
    res. setHeader( 'Last-modified', mtime. touTcString()

2.  etag 密码戳。依据内容

场景

1. html 协商缓存
2. 静态文件 强制缓存 url 发生变化 打包文件名 hash 文件名

### Service Worker 缓存

### CDN 缓存

### Push 缓存

### 使用服务端渲染

### 使用预渲染

## 渲染优化

关键渲染路径优化
Javascripe 执行优化
计算样式优化
页面布局与重绘优化
合成处理

## 资源加载优化

图片延迟加载
视频加载
路由懒加载
资源优先级

## 图片优化

图片基础
图片格式
图像使用建议

## 构建优化

压缩与合并
使用 webpack 进行资源构建
webpack 优化性能

## 特定场景优化方案
