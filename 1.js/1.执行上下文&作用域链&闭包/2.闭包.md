
## 闭包
- 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前作用域之外执行
```
function foo () {
  var a=3;
  function bar () {
    console.log(a) //3 
  }
  bar()
}
foo()
```
- 闭包
```
function foo() {
  var a= 2;
  function bar() {
    console.log(a)
  }
  return bar;
}
var baz = foo();
baz(); // 2 
这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的 词法作用域。
```
```
function foo() {
  var a = 2;
  function baz() {
    console.log(a); 
  }
  bar(baz)
}
function bar (fn) {
  fn() // 这就是闭包
}
```

```
var fn;
function foo() {
  var a = 2;
  function baz() {
    console.log(a)
  }
  fn = baz // 将baz分配给全局变量
}

function bar() {
  fn(); // 这就是闭包
}
foo()
baz() //2
```
- 无论通过何种手段，将内部函数传递到所在的词法作用域外，都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。
###### eg
```
function wait (message) {
  setTimeout(function timer() {
    console.log(message);
  },1000)
}
wait('hello')
将一个内部函数传递给setTimeout(...)。timer具有涵盖wait(...)作用域的闭包，因此还保有对message的引用。

wait(...)执行100ms之后，内部作用域并不会消失，timer函数依然保有wait(...)作用域的闭包
```
```
function setupBot(name, selector) {
  $(selector).click(function activator() {
    console.log('Activating' + name)
  })
}
setupBot( "Closure Bot 1", "#bot_1" ); 
setupBot( "Closure Bot 2", "#bot_2" );
如果将函数（访问它们各自的词法作用域）当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。
在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使 用了回调函数，实际上就是在使用闭包！
```

```
for(var i = 0; i<=5; i++) {
  setTimeout(function timer() {
    console.log(i); 
  },1000);
}
// 5次6  是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。
//延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，
所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。

改进1
for(var i =1; i<=5;i++) {
  (function(j) {
     setTimeout(function timer() {
    console.log(j); 
  },1000);
  })(i)
}
// 在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问

改进2
for(let i = 0; i<=5; i++) {
  setTimeout(function timer() {
    console.log(i); 
  },1000);
}

```

##### 模块
```
function foo() {
  var something = 'cool';
  var another = [1,2,3];
  function doSomething() {
    console.log(something);
  }
  function doAnother() {
    console.log(another.join("!"));
  }
}
```
```
function CoolModule() {
  var something = 'cool';
  var another = [1,2,3];
  function doSomething() {
    console.log(something);
  }
  function doAnother() {
    console.log(another.join("!"));
  }
}
var foo = CoolModule();
foo.doSomething(); // cool
foo.doAnother(); // 1! 2! 3!
```


- 必要条件
  - 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）
  - 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问修改私有状态
  ```
  单例模式

  var foo = (function CoolModule() {
    var something = "cool";
    var another = [1, 2, 3];
    function doSomething() { 
      console.log( something ); 
    }
    function doAnother() { 
      console.log( another.join( " ! " ) ); 
    }
    return { 
      doSomething: doSomething, 
      doAnother: doAnother 
    }; 
  })(); 
  foo.doSomething(); // cool 
  foo.doAnother(); // 1 ! 2 ! 3
  ```

  ```
  命名将要作为公共 API 返回的对象
  var foo = (function CoolModule(id) {
    function change() {
      // 修改公共API
      publicAPI.identify = identify2;
    }
    function identify1() {
      console.log(id);
    }
    function identify2() {
      console.log(id.toUpperCase())
    }
    var publicAPI = {
      change: change,
      identify: identify1
    }
    return publicAPI
  })('foo module')

  foo.identify() // foo module
  foo.change()
  foo.identify() // FOO MODULE
  ```
  - es6中的模块机制
  ```
  bar.js
  function hello(who) {
    return "Let me introduce: " + who; 
  }
  export hello;

  foo.js// 仅从 "bar" 模块导入 hello()
  import hello from "bar";
  var hungry = "hippo";
  function awesome() { 
    console.log( hello( hungry ).toUpperCase() ); 
  }
  export awesome; 
  
  baz.js// 导入完整的 "foo" 和 "bar" 模块
  module foo from "foo"; 
  module bar from "bar"; 
  console.log( bar.hello( "rhino" ) ); // Let me introduce: rhino 
  foo.awesome(); // LET ME INTRODUCE: HIPPO
  ```


```javascript
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(new Date(), i)
  }, 1000)
}

console.log(new Date(), i)
```

输出 5,5,5,5,5,5

循环里面的 5 立即输出，不会进行 1s 的时间间隔；这些定时器都会在 1 秒之后触发，而循环完的输出是立即执行的

## 追问 1

想要输出 5 -> 0,1,2,3,4

1.立即执行

```javascript
for (var i = 0; i < 5; i++) {
  ;(function (j) {
    // j = i
    setTimeout(function () {
      console.log(new Date(), j)
    }, 1000)
  })(i)
}

console.log(new Date(), i)
```

2.`setTimeout` 文档

```javascript
for (var i = 0; i < 5; i++) {
  setTimeout(
    function (j) {
      console.log(new Date(), j)
    },
    1000,
    i
  )
}

console.log(new Date(), i)
```

3.JS 中基本类型（Primitive Type）的参数传递是按值传递（Pass by Value）的特征

```javascript
var output = function (i) {
  setTimeout(function () {
    console.log(new Date(), i)
  }, 1000)
}

for (var i = 0; i < 5; i++) {
  output(i) // 这里传过去的 i 值被复制了
}

console.log(new Date(), i)
```

4.ES6 的 let

```javascript
for (let i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(new Date(), i)
  }, 1000)
}

console.log(new Date(), i)
```

## 追问 2

想要输出 0 -> 1 -> 2 -> 3 -> 4 -> 5 中间间隔 1s

1.使用回调函数

```javascript
for (var i = 0; i < 5; i++) {
  ;(function (j) {
    setTimeout(function () {
      console.log(new Date(), j)
    }, 1000 * j) // 这里修改 0~4 的定时器时间
  })(i)
}

setTimeout(function () {
  // 这里增加定时器，超时设置为 5 秒
  console.log(new Date(), i)
}, 1000 * i)
```

2.使用 promise

```javascript
const tasks = [] // 这里存放异步操作的 Promise
const output = (i) =>
  new Promise((resolve) => {
    setTimeout(() => {
      console.log(new Date(), i)
      resolve()
    }, 1000 * i)
  })

// 生成全部的异步操作
for (var i = 0; i < 5; i++) {
  tasks.push(output(i))
}

// 异步操作完成之后，输出最后的 i
Promise.all(tasks).then(() => {
  setTimeout(() => {
    console.log(new Date(), i)
  }, 1000)
})
```

3.`async/await`

```javascript
// 模拟其他语言中的 sleep，实际上可以是任何异步操作
const sleep = (timeountMS) =>
  new Promise((resolve) => {
    setTimeout(resolve, timeountMS)
  });

  (async () => {
  // 声明即执行的 async 函数表达式
  for (var i = 0; i < 5; i++) {
    if (i > 0) {
      await sleep(1000)
    }
    console.log(new Date(), i)
  }

  await sleep(1000)
  console.log(new Date(), i)
})()
```
