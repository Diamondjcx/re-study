# 浏览器缓存

- 动机：
  - 当浏览器加载一个 html 页面时，一些外部资源如 js\css\img 不经常变化。如果每次都加这些资源，会导致资源浪费，加载时间过长，影响用户体验
  - 将静态资源存储在浏览器内部，下次请求相同资源可以直接使用。
- 作用：
  - 提高首屏加载速度，优化用户体验
  - 减少流量消耗
  - 减轻服务器压力

通常情况下的步骤是:

1. 客户端向服务器发出请求，请求资源
2. 服务器返回资源，并通过响应头决定缓存策略
3. 客户端根据响应头的策略决定是否缓存资源（这⾥假设是），并将响应头与资源缓存下来
4. 在客户端再次请求且命中资源的时候，此时客户端去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断 是直接读取本地缓存还是与服务器协商缓存

## 什么时候触发强缓存和协商缓存？
### 强缓存：满足强缓存命中规则，则不会再像服务器发送请求。
    判断条件：根据`Response header`中的 Expire、Cache-control 判断
  - 1. Expire：Expires是http1.0提出的⼀个表示资源过期时间的header，它描述的是⼀个绝对时间，由服务器返回，
    2. Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效
  - Cache-Control: Cache-Control 出现于 HTTP / 1.1，优先级⾼于 Expires ,表示的是相对时间，资源缓存的最大时间
    ```js
    Cache-Control:max-age=600   缓存的最大有效时间为600s
    ```
    1. Cache-Control: public可以被所有⽤户缓存，包括终端和CDN等中间代理服务器 
    2. Cache-Control: private只能被终端浏览器缓存，不允许中继缓存服务器进⾏缓存 
    3. Cache-Control: no-cache,先缓存本地，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使⽤ 
    4. Cache-Control: no-store，不会产⽣任何缓存
  
在缓存有效期内命中缓存，浏览器会直接读取本地的缓存资源，当缓存过期之后会与服务器进⾏协商

### 协商缓存：当缓存过期之后会与服务器进⾏协商

1. 当第⼀次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期抑或它的属性设置为no-cache时，那么浏览器第⼆次请求时就会与服务器进⾏协商。
2. 如果缓存和服务端资源的最新版本是⼀致的，那么就⽆需再次下载该资源，服务端直接返回304 Not Modified 状态码， 如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是 200 Ok。

- Last-Modified，If-Modified-Since 第一次请求，服务会返回最后修改时间。再次请求时，请求携带的上一次修改的时间。服务器再跟服务器上的对应资源进⾏⽐对，如果服务器的资源更新，那么返回最新的资 源，此时状态码200，当服务器资源跟客户端的请求的部⾸时间⼀致，证明客户端的资源是最新的，返回304状态码， 表示客户端直接⽤缓存即可。
缺点：最小单位是秒。如果短时间内修改，Last-Modified 并不会改变  
      
- Etag，If-None-Match：由文件内容 hash 生成的，可以保证资源的唯一性，资源发生改变就会导致 Etag 发生变化
优先校验 Etag，如果 Etag 相等就会继续比对 Last-Modified



Size 中会出现的情况

- 200 from disk cache 磁盘缓存 不请求网络资源，在磁盘当中，一般非脚本会存在磁盘当中
- 200 from memory cache 内存缓存 不请求网络资源，资源在内存当中，一般脚本、字体、图片会存在内存当中
- 200 资源大小数值 从服务器下载最新资源
- 304 报文大小 请求服务端发现资源没有更新，使用本地资源

用户行为对浏览器缓存的影响

- 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
- 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
- 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control:no-cache(为了兼容，还带了 Pragma:no-cache),服务器直接返回 200 和最新内容。



