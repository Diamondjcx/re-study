# url 输入做了什么

## 前置知识点

需要各个进程之间的相互配合。

浏览器进程：用户交互、子进程管理和文件储存

网络进程：向浏览器进程和渲染进程提供网络下载等功能

渲染进程：从网络上下载的 HTML、Javascript、css、图片等资源解析为显示和可交互的页面

## 整个过程

用户发出 URL 请求到页面开始解析的这个过程，叫做导航

1、浏览器进程接收到用户输入的 URL 请求，浏览器进程将该 URL 转发给网络进程

2、网络进程中发起真正的 URL 请求

3、浏览器进程接收到网络进程的响应头数据之后，发送“提交导航”消息到渲染进程

4、渲染进程接收到“提交导航”的消息之后，开始准备接收 HTML 数据，（直接和网络进程建立数据管道

5、渲染进程会向浏览器进程“确认提交”，告诉浏览器进程：“已经准备好接受和解析页面数据了”

6、浏览器进程接收到渲染进程“提交文档”的消息之后，开始移除之前旧的文档，更新浏览器进程中的页面状态

```
          URL请求                            发起请求
浏览器进程 ------------------------> 网络进程 ------->
          <------------------------    |
    |      相应数据                     |
    |                                  |
提交 |                                 |
文档 | 提交导航                          |
    |                                  |
渲染进程                              渲染进程

```

## 输入 URL 到页面展示

1、用户输入

判断是否是搜索内容

- 是，使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL
- 否，"time.geekbang.org"符合 HRL 规则，会根据规则，把这段内容加上协议，合称为完整的 URL

用户输入关键字并键入回车之后，意味着当前页面即将要被替换成新的页面，在这个流程之前，浏览器会给当前页面一次执行 beforeunload 事件的机会。

beforeunload 事件允许页面在退出之前执行一些数据清理操作，可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。

页面没有监听 beforeunload 事件或统一了继续后续流程

2、URL 请求过程

页面资源请求过程。浏览器进程会通过进程间通信把 URL 发送至网络进程。由网络进程发送请求

是否有缓存
有: 直接返回资源给浏览器进程
无：网络请求过程

网络请求过程

HTTP
DNS 解析获取请求域名的服务器 IP 地址
HTTPS
建立 TLS 连接

### 1）、重定向

返回 301 或者 302，说明服务器需要浏览器重定向到其他 HRL，网络进程会从响应头的 Location 字段里面读取重定向的地址，重新发起请求

```javascript
curl -I http://time.geekbang.org/

HTTP/1.1 302 Found
Date: Wed, 14 Apr 2021 13:26:59 GMT
Content-Type: text/html
Content-Length: 154
Connection: keep-alive
Location: https://time.geekbang.org/
Via: HTTP/1.1 SLB.47

```

在导航过程中，如果服务器相应行的状态包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果相应行是 200，那么表示浏览器可以继续处理该请求

### （2）、响应数据类型处理

URL 请求的数据类型，根据 Content-Type 区分 响应体数据是什么类型。

如果是下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程到此结束
如果是 HTML，那么浏览器会继续进行导航流程

### （3）、准备渲染进程

会为每个页面分配一个渲染进程，每打开一个新页面就会配套创建一个新的渲染进程，也有例外，浏览器会让多个页面直接运行在同一个渲染进程中。

同一站点：同根域名+协议

```javascript

https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080

```

渲染进程策略：

- 通常情况下，打开新的页面都会使用单独的渲染进程
- 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程

### （4）提交文档

浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程

浏览器接收到网络进程的响应头数据之后，向渲染进程发起“提交文档”的消息

渲染进程接收到之后，会和网络进程建立传输数据的管道

传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程

浏览器进程收到“确认提交”的消息之后，会更新浏览器界面状态，包括安全状态、地址栏 URL、前进后退的历史状态，并更新 WEB 页面

### （5）渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载了。

#### 构建 DOM 树

因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构--DOM 树

#### 样式计算

CSS 样式来源主要有三种

1、把 CSS 转换为浏览器能够理解的结构

- 通过 link 引用的外部 CSS 文件
- <style>标记内的CSS
- 元素的 style 属性内嵌的 CSS
  因为浏览器也无法理解这些纯文本的 CSS 样式，所以当选人引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets

2、转换样式表中的属性值，使其标准化

```css
body {
  font-size: 2em;
}
p {
  color: blue;
}
span {
  display: none;
}
div {
  font-weight: bold;
}
div p {
  color: green;
}
div {
  color: red;
}
```

2em、blue、bold 这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值

3、计算出 DOM 树中每个节点的具体样式
继承和层叠

#### 布局阶段

我们有 DOM 树和 DOM 树中元素的样式，不足以显示页面，因为不知道 DOM 元素的几何位置信息。
接下来需要计算出 DOM 树中可见元素的几何位置，这个计算过程叫做布局。

1、创建布局树
在显示之前，额外构建一颗只包含可见元素布局树。

2、布局计算
计算布局树节点的坐标位置

#### 分层

渲染引擎需要为特定的节点生成专用的图层，并生成一颗对应的图层树。
并不是布局树的每个节点都包含一个图层
1、拥有层叠上下文属性的元素会被提升为单独的一层
2、需要裁剪的地方也会被创建为图层

#### 图层绘制

会把一个图层的绘制拆分成很多小的绘制指令

#### 栅格化操作

当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程
合成线程会将图层划分为图块
合成线程会按照视口附近的图块优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。

#### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——"DrawQuard",提交给浏览器进程

#### 渲染流程

- 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
- 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
- 创建布局树，并计算元素的布局信息。
- 对布局树进行分层，并生成分层树。
- 为每个图层生成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
- 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

重绘省去了布局和分层阶段，执行效率会比重排操作要高一点
相对于重绘和重排，合成能大大提升绘制效率，因为是在非主线程上合成，没有占用主线程的资源，避开了布局和绘制两个子阶段（CSS 的 transform
