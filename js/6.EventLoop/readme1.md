# EventLoop

## 线程与进程

JS 是单线程的，如果是多个线程，一个线程操作 DOM，另一个线程删除 DOM，会有问题，所以是单线程的。

进程是 CPU 资源分配的最小单位；线程是 CPU 调度的最小单位

- 进程好比工厂，有单独的专属自己的工厂资源

- 线程好比工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n 的关系。也就是说一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线

- 工厂的空间是工人们共享的，这象征一个进程的内存空间是共享的，每个线程都可用这些共享内存

- 多个工厂之间独立存在。

多线程与多进程

多线程：同一时间同一系统，允许两个或两个以上的线程同时运行。听歌的同时打开编辑器敲代码
多进程：一个程序中可以同时运行多个不同的线程来执行不同的任务

以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。

## 浏览器内核

- GUI 渲染线程

主要负责页面的渲染，解析 HTML、CSS、构建 DOM 树，布局和绘制

重绘重排执行该线程

与 JS 引擎线程互斥

- JavaScript 引擎线程

负责处理 JavaScript 脚本，执行代码

主要负责执行准备好待执行的事件，比如定时器计数结束或异步请求成功并正确返回，将依次进入任务队列，等待 JS 引擎线程的执行

- 定时触发器线程

setTimeout、setInterval

- 事件触发线程

主要负责将准备好的事件交给 JS 引擎线程执行
比如 setTimeout 定时器计数结束，ajax 等异步请求成功并触发回调函数或用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS 引擎线程执行

- 异步 http 请求线程

负责执行异步请求一类的函数的线程，如 Promise、axios、ajax

## 浏览器中的 EventLoop

macro（宏任务）队列和 micro（微任务）队列 宏任务有多个，微任务队列只有一个

- macro：setTimeout、setInterval、setImmediate、script、I/O 操作、UI 渲染等

- micro：process.nextTick、new Promise().then(回调)、MutationObserver(html5 新特性)

EventLoop 过程解析

- 一开始执行栈空,我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。
- 全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。
- 上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。
- 执行渲染操作，更新界面
- 检查是否存在 Web worker 任务，如果有，则对其进行处理
- 上述过程循环往复，直到两个队列都清空

当某个宏任务执行完成后，会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列中的任务，依次类推。

```javascript
Promise.resolve().then(() => {
  console.log('Promise1')
  setTimeout(() => {
    console.log('setTimeout2')
  }, 0)
})
setTimeout(() => {
  console.log('setTimeout1')
  Promise.resolve().then(() => {
    console.log('Promise2')
  })
}, 0)
```

- 一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出 Promise1，同时会生成一个宏任务 setTimeout2
- 然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1
- 在执行宏任务 setTimeout1 时会生成微任务 Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2
- 清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2

## Node 中的 Event Loop

## Node 与浏览器的 Event Loop 差异

# 总结
