
# 前端安全问题

## 概况
### 跨站脚本（XSS）
代码注入
起因：没有对用户的输入进行严格的限制
结果：使得攻击者可以将脚本上传到帖子让其他人浏览到有恶意脚本的页面
方式：JavaScript、VBScript、CSS、Flash
### iframe滥用
iframe是第三方提供的，默认情况下不受我们控制，攻击者可以在iframe中运行JavaScript脚本、Flash插件、弹出对话框等，可能会破坏前端用户体验
### 跨站点请求伪造（CSRF）
攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新
### 恶意第三方库
前端应用和后端服务器应用都会借助第三方库进行快速开发，一旦第三方库被植入恶意代码很容易引起安全问题

## XSS
### 分类： 存储型、反射型、DOM型
#### 存储型XSS攻击步骤
1. 攻击者将恶意代码提交到目标网站的数据库中
2. 用户打开目标网站时，网站服务端将恶意代码从数据库去除，拼接在HTML中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

常见于带有用户保存数据的网站功能，如：论坛发帖、商品评论、用户私信
#### 反射型XSS攻击步骤
1. 攻击者构造出特殊URL，其中包含恶意代码
2. 用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中去除，拼接在HTML中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

常见于通过URL传递参数的功能，如网站搜索、跳转等
#### DOM型XSS攻击步骤
1. 攻击者构造出特殊的URL，其中包含恶意代码
2. 用户打开带有恶意代码的URL
3. 用户浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
#### 反射型XSS、存储型XSS和DOM型XSS的区别：
存储型XSS的恶意代码存在数据库
反射型XSS的恶意代码存在URL里
DOM型XSS攻击，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种XSS都属于服务端的安全漏洞
### 预防
攻击的两大因素：
1. 攻击者提交恶意代码
2. 浏览器执行恶意代码

针对第一个要素：输⼊侧过滤能够在某些情况下解决特定的 XSS 问题，但会引⼊很⼤的不确定性和乱码问题

针对第二个要素：
1. 防止HTML中出现注入
2. 防止JavaScript执行时，执行恶意代码

####  预防存储型和反射型 XSS 攻击
服务端去除恶意代码后，插入到响应HTML里，攻击者可以编写的’数据‘被内嵌到’代码‘中，被浏览器锁执行
1. 改成纯前端渲染，把代码和数据分隔开
2. 对HTML做充分转义

#### 预防DOM型XSS攻击
实际上是网站前端JavaScript代码本身不够严谨，把不可信的数据当做代码执行了。
把字符串作为代码运行的api，很容易产生安全隐患

 .innerHTML 、 .outerHTML 、 document.write() --->.textContent 、 .setAttribute()
 vue：v-html / dangerouslySetInnerHTML

 DOM 中的内联事件监听器，如 location 、 onclick 、 onerror 、 onload 、 onmouseover 等， <a> 标签的 href 属 性，JavaScript 的 eval() 、 setTimeout() 、 setInterval() 等，

#### 其他XSS防范措施
##### Content Security Policy
- 禁止加载外域代码，防止复杂的攻击逻辑
- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域
- 禁止内联脚本执行
- 禁止未授权的脚本执行
- 合理使用上报可以及时发现XSS，利于尽快修复问题
##### 输入内容长度控制
对于不受信任的输⼊，都应该限定⼀个合理的⻓度。虽然⽆法完全防⽌ XSS 发⽣，但可以增加 XSS 攻击的难度
##### 其它安全措施
- HTTP-only Cookie: 禁⽌ JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注⼊后也⽆法窃取此 Cookie。 
- 验证码：防⽌脚本冒充⽤户提交危险操作。- 

## CSRF跨站请求伪造
攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

CSRF攻击流程：
1. 受害者登录 a.com ，并保留了登录凭证（Cookie） 
2. 攻击者引诱受害者访问了 b.com
3. b.com 向 a.com 发送了⼀个请求： a.com/act=xx 浏览器会默认携带a.com的Cookie 
4. a.com接收到请求后，对请求进⾏验证，并确认是受害者的凭证，误以为是受害者⾃⼰发送的请求 
5. a.com以受害者的名义执⾏了act=xx 
6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执⾏了⾃⼰定义的操作

### 分类
#### GET类型的CSRF
GET类型的CSRF利⽤⾮常简单，只需要⼀个HTTP请求
#### POST类型的CSRF
这种类型的CSRF利⽤起来通常使⽤的是⼀个⾃动提交的表单
#### 链接类型的CSRF
这种类型通常是在论坛中发布的图⽚中嵌⼊恶意链接，或者以⼴告的形式诱导⽤户中招，攻击者通常会以⽐较夸张的词语诱骗⽤户点击
### 预防CSRF
CSRF的两个特点：
 1. CSRF（通常）发⽣在第三⽅域名。 
 2. CSRF攻击者不能获取到Cookie等信息，只是使⽤。


 阻⽌不明外域的访问 
 - 同源检测：
   
 - Samesite Cookie 

 提交时要求附加本域才能获取的信息
 - CSRF Token 
 - 双重Cookie验证

#### 同源检测
 1. 使⽤Origin Header确定来源域名: 在部分与CSRF有关的请求中，请求的Header中会携带Origin字段,如果Origin存 在，那么直接使⽤Origin中的字段确认来源域名就可以
 2. 使⽤Referer Header确定来源域名: 根据HTTP协议，在HTTP头中有⼀个字段叫Referer，记录了该HTTP请求的来 源地址
#### CSRF Token
CSRF Token的防护策略分为三个步骤： 
1. 将CSRF Token输出到⻚⾯中 
2. ⻚⾯提交的请求携带这个Token 
3. 服务器验证Token是否正确
#### 双重Cookie验证
双重Cookie采⽤以下流程： 
1. 在⽤户访问⽹站⻚⾯时，向请求域名注⼊⼀个Cookie，内容为随机字符串（例如 csrfcookie=v8g9e4ksfhw ）。
2. 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例 POST https://www.a.com/comment? csrfcookie=v8g9e4ksfhw ）。 
3. 后端接⼝验证Cookie中的字段与URL参数中的字段是否⼀致，不⼀致则拒绝。
#### Samesite Cookie属性
Google起草了⼀份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它⽤来标明这个 Cookie是 个“同站 Cookie”，同站Cookie只能作为第⼀⽅Cookie，不能作为第三⽅Cookie，Samesite 有两个属性值: 
1. Samesite=Strict: 这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三⽅ Cookie 
2. Samesite=Lax: 这种称为宽松模式，⽐ Strict 放宽了点限制,假如这个请求是这种请求且同时是个GET请求，则这个 Cookie可以作为第三⽅Cookie


## 网络劫持
### 分类
#### DNS劫持(输⼊京东被强制跳转到淘宝这就属于dns劫持)
DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器 
302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容
#### HTTP劫持(访问⾕歌但是⼀直有贪玩蓝⽉的⼴告)
由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告
###  如何应对⽹络劫持?
DNS劫持由于涉嫌违法,已经被监管起来,现在很少会有DNS劫持,⽽http劫持依然⾮常盛⾏.
全站HTTPS,将HTTP加密,这使得运营商⽆法获取明⽂,就⽆法劫持你的响应内容.
## 中间⼈攻击
1. 客户端发送请求到服务端，请求被中间⼈截获 
2. 服务器向客户端发送公钥 
3. 中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个【伪造的】公钥，发给客户端 
4. 客户端收到伪造的公钥后，⽣成加密hash值发给服务器 
5. 中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器 
6. 服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端