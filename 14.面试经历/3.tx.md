一面：

自我介绍完之后

介绍下最近做的项目
项目背景、项目技术点、项目遇到的问题及怎么解决的

# 陈列打卡系统

## 第一点：做了哪些优化

### 1、地图数据（直接从高德地图中拉下来的数据）

缺点：
1）地图中的数据不是一成不变的，有些地区可能由于政策的改变，由县升级为区
2）地图中的数据会有很多，会增加打包体积，影响加载速度及用户体验
解决：使用了高德地图 api，根据 code 获取地图中的数据，可以有效的减少打包体积（四川省下面的市区、全国）
7.99 MB - 3.52 MB - 5.76 MB（加上全国数据）

vue-cli：@vue/cli 4.3.1
vue：2.5.2

### 2、路由的按需加载

const RoutersView = () => import( /_ webpackChunkName: 'layout' _/ '../views/routers-view')
用函数包裹起来

### 3、elementUI 按需加载

打包体积增大

### 4、webpack 优化 compression-webpack-plugin 开启 gzip

gzip 是需要服务端配置的，当开启时会压缩我们的线上代码，但是如果我们前端已经使用 gzip 压缩过，那么服务端就会直接使用已经压缩好的代码

### 5、splitChunks chunk-vender 分割代码

chunk-vendors 的 js 文件，这个文件包含了业务代码和一些引入的第三方库代码，所以一般体积比较大，浏览器加载时也耗时更多

其实我们可以将这部分代码做一个分割，分成多个文件，这样浏览器加载时会并行加载，而且对于不变的代码，会直接从缓存中读取，速度得到提升。

### 6、有了解到可以使用 cdn，但是可能会不稳定

直接配置 config.externals HtmlWebpackPlugin 插件进行引入

cdn 引入的方式虽然能极大改善网页加载速度，但我还是不会用这个功能，项目还不需要非得这样的优化，也怕 cdn 不稳定。觉得需要的还是可以上的

### 7、图片文件的压缩

上线之前统一进行图片压缩 tiny
或者使用 image-webpack-loader

### 8、去掉一些没有必要的第三方包

只使用了 lodash 的深拷贝。就可以直接摒弃掉这个库，当然也可以进行按需加载

### 9、打包第三方包时，忽略一些文件内容

webpack 中的 IgnorePlugin 插件，可以在打包第三方包时忽略一些文件内容，有效减小打包文件体积。一个典型的案例就是忽略 moment 插件的语言包，moment 自带有很多语言包，即使你不用这些包，也会被一起打包了，这时候就可以使用 ignorePlugin 来忽略打包这部分文件，配置插件：

关于时间格式化，我还是喜欢自己去封装，或者可以使用 dayjs 这个库，更轻量化。

### 10、提升项目构建速度

这个适用于开发环境，每次构建都需要打包引入的第三方模块，如果不打包这些模块，那么构建速度将大大提升，这正是 DllPlugin 要做到的事。

说的明白点就是在构建项目之前，先把一些第三方包打包好，然后项目构建时直接引用这些打包好的第三方包，提升项目构建速度。

## 第二点：loader/plugin 做了什么功能及原理

功能：根据环境不同，静态文件路径前缀不同

### loader

转换器；用于对模块源代码进行转换。

特性：
链式调用，链中的每个 loader 都将对资源进行转化，从上到下，从右到左

可以是同步也可以是异步

运行在 node.js 中，并且能够执行任何操作

loader 可以通过 options 对象配置

除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。

插件(plugin)可以为 loader 带来更多特性。

loader 能够产生额外的任意文件。

编写步骤：
Loader 就是⼀个函数，声明式函数，不能⽤箭头函数，因为要使用 this 获取对象

拿到源代码，作进⼀步的修饰处理，再返回处理后的源码就可以了

### plugins

plugin 可以在 webpack 运⾏到某个阶段的时候，帮我们做⼀些事情，类似于⽣命周期的概念
扩展插件，在 Webpack 构建流程中的特定时机注⼊扩展逻辑来改变构建结果或做你想要的事情。
作⽤于整个构建过程

webpack 插件是一个具有 apply 方法的 javascript 对象，apply 方法会被 webpack.compiler 调用，并且在整个编译生命周期都可以访问 compiler 对象

## 第三点：axios 封装统一请求

## 第四点：怎么封装的

# 微服务

第二个项目：

## 1、qiankun 原理

### 什么是微前端

微前端就是将不同的功能按照不同维度拆分成多个子应用，通过主应用来加载这些子应用

微前端的核心在于拆 拆完再合

### 为什么要使用微前端

- 不同团队开发同一个应用，技术栈不同
- 希望每个团队都独立开发、独立部署
- 项目中需要老的应用代码

可以将一个应用拆分为若干个子应用，将子应用打包成一个个的 lib，当路径切换时加载不同的子应用，
这样每个子应用都是独立的，这样每个子应用都是独立的，技术栈也不用做限制了，从而解决了前端协同开发问题

### how 怎样落地微前端？

18 年 Single-SPA 用于前端微服务化的 javascript 前端解决方案（本身没有处理样式隔离<父子，兄弟组件>，js 执行隔离<污染变量>）实现了路由劫持和应用加载

19 年，qiankun 基于 Single-SPA 提供了更加开箱即用的 API（single-spa sandbox + import
-html-entry）做到了技术栈无关，并且接入简单（像 iframe 一样简单
）

总结：子应用可以独立构建，运行时动态加载，主子应用完全解耦，技术栈五官，靠的是协议接入（子应用必须导出 bootstrap、mount、unmount 方法）

iframe 一个页面套各种应用，切换路由之后，页面一刷新，状态都没了

应用通信：

- 基于 url 进行数据传递，但是传递消息能力弱
- 基于 CustomEvent 实现通信
- 基于 props 主子应用间通信
- 使用全局变量、Redux 进行通信

公共依赖

- CND - extrnals
- webpack 联邦模块

## 2、通读 axios 之后学到了什么

## 3、怎么做的？

## 4、

## 5、http2 怎么推广的，有什么问题

## 6、打开速度怎么提升的，怎么发觉问题
