# 提升开发体验

## SourceMap

### 为什么

当出现错误时，控制台输出的错误行是打包后的行数，不准确 不太友好

配置 SourceMap 之后，输出的错误就是源代码的行数，准确定位，找到错误位置

### 是什么

原代码和构建后的代码一一映射关系，

### 怎么用

1. 开发模式 cheap-module-source-map
   优点：打包编译速度快，只包含行映射
   确定：没有列映射

2. 生产模式 source-map
   优点：包含行/列映射
   缺点：打包编译速度更慢

# 提升打包构建速度

## HMR

热模块替换，项目 loader 自带功能 vue-loader

## OneOf

如果不配置，假如第一个配置 loader 可以处理，但还是要走下面的配置 进行判断是否可以处理

配置后，一旦有 loader 可以处理，就不再进行后面的判断

## include/exclude

引入第三方，需要排除处理
打包速度快一些
包含哪些文件 排除哪些文件 只处理某些文件

## cache

1. 为什么
   每次打包 js 文件都要经过 eslint 检查和 babel 编译，速度比较慢
   可以缓存之前的 eslint 检查和 babel 编译结果，这样第二次打包速度就会更快了
2. 是什么
   对 eslint 检查和 babel 编译结果进行缓存

## 多进程打包

多进程打包：开启电脑的多个进程同时干一件事，速度更快。
需要注意：请仅在特别耗时的操作中便用，因为每个进程启动就有大约为 600ms 左右开销。

thread-loader

# 减少代码体积

## tree-shaking

用到了哪些代码 就打包哪些代码 把没有用到的代码筛掉

1. 为什么
   开发时定义了一些工具函数库或引用第三方工具函数库或组件库
   如果没有特殊处理的话我们打包会引入整个库，但是实际上可能只用到了一小部分功能，这样整个库打进去，体积太大了
2. 是什么
   移除没有用到的代码
3. 怎么用
   默认开启 无需配置

## babel

1. 为什么
   babel 为编译的每个文件都插入了辅助代码，使代码体积过大
   babel 对一些公共方法是用了非常小的辅助代码（比如\_extend,默认会被添加到每一个需要它的文件中）
   可以将这些辅助代码作为一个独立模块，避免重复引入
2. 是什么

   Bbabel/plugin-transforw-runtine: 禁用了 Babel 自动对每个文件的 runtime 注入，而是引入
   Bbabel/plugin-transform-runtine 井且使所有辅助代码从这里引用。

## 图片减少体积 压缩 Image Minimizer

1. 为什么
   开发如果项目中引用了较多图片，那么图片体积会比较大，将来请求速度比较慢。
   我们可以对图片进行压缩，减少图片体积。

注意：如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。

2. 是什么
   Image-nininizer-webpack-plugin:用来压缩图片的插件
   怎么用

3. 下载包
   npn 1i inage-wininizer-webpack-plugin imagenin -D
   还有剩下包需要下载，有两种模式：
   无损压缩
   npm install fnagomin-gifsicle inagomin-Jpegtran imagenin-optipng imagenin-svpo D
   有损压缩
   npe Instoll iaagemin-gifsicle inagenin-moz jpeg imagenin-pngquant imageain-svpo -D

# 提高代码运行性能

## code split 拆出来的 chunk

1. 为什么
   打包代码时会持所有 j 文件打包到一个文件中，体积太大了，我们如果只要谊染首页，就应该只加载首页的 js 文件，其他文件不应该加载。

所以我们需要将打包生成的文件进行代码分割，生成多个 js 文件，渲染哪个页面就只加载哪个 js 文件，
这样加载的资源就少，速度就更快。

2. 是什么
   代码分劃(Code Split） 主要做了两件事：

   1. 分割文件：将打包生成的文件进行分割，生成多个 js 文件。
   2. 按需加载：需要哪个文件就加载哪个文件。

3. 怎么用
   代码分割/实现方式有不同的方式，
   1. 多入口 打包多个出口文件
   2. 多入口提取公共模块
   3. 多入口按需加载
   4. 单入口
   5. 给模块命名
   6. 统一命名

## preload /prefrtch

1. 为什么
   我们前面已经做了代码分割，同时会使用 import 动态导入语法来进行代码按需加载（我们也叫懒加载，比如路由懒加载就是这样实现的），
   但是加载速度还不够好，比如：是用户点击按钮时才加载这个资源的，如果资源体积很大，那么用户会感觉到明品卡顿效果。
   我们想在浏览器空闲时间，加载后续需要使用的资源，我们就需要用上 Preload 或 Prefetch 技术。

2. 是什么
   Preload：告诉浏览器立即加载资源。
   prefetch：告诉浏览器在空闲时才开始加载资源。

   它们共周点：

   1. 都只会加载资源，并不执行。
   2. 都有緩存。

   它们区别：

   1. Preload 加载优先级高，Prefetch 加载优先級低。
   2. Preload 只能加载当前页面需要使用的资源，prefetch 可以加教当前页面资源，也可以加载下一个页面需要使用的资源，

   总结：
   当前页面优先级高的资源用 Preload 加载。
   下一个页面需要使用的资源用 Prefetch 加载。
   它们的问题：兼客性较差，

## 缓存最大化 network cache

1. 文件内容发生变化时 hash 才发生变化 只改变发生变化的文件
   文件引入

2. 缓存失效时 加载新的资源

## Core-js

1. 为什么
   过去我们使用 babel 对 js 代码进行了兼容性处理，其中使用@babel/preset-env 智能预设来处理兼容性问题，
   它能将 ES6 的一些语法进行编泽转换，比如箭头函数数、点点点运算符等。但是如果是 async 函数、promise 对象、数组的一些方法(includes) 等，它没办法处理，

所以此时我们 js 代码仍然存在兼容性问题，一旦遇到低版本浏览器会直接报错。所以我们想要将 js 兼容性问题彻底解决

2. 是什么
   core-js 是专门用来做 ES6 以及以上 API 的 polyfinl
   polyfil1 翻译过来叫做垫片/补丁，就是用社区上提供的一段代码，让我们在不兼容某些新特性的浏览器上，使用该新特性

## PWA

1. 为什么
   开发 Web App 项目，项目一旦处于网路商线情况，就没法访问了，
   我们希望给项自提供商线体验。
2. 是什么
   浙进式网路应用程序(progressive web application - PWA)：是一种可以提供类似于 native app(原生应用程南） 体验的 Web App 的技术。
   其中最重要的是，在离线(offline) 时应用程序公够继续运行功能。
   内部通过 Service Workers 技术实现的。

# 总结

我们从 4 个角度对 webpack 和代码进行了优化：

1. 提升开发体验
   使用 Source Map 让开发或上线时代码报铺能有更加准确的错识提示。
2. 提升 webpack 提升打包构理速度
   1. 使用 HotwoduleReplacement 让开发时只重新编择打包更新变化了的代码，不变的代码便用缓存，从而便更新速度更快。
   2. 便用 Oneof 让资源文件一旦被某个 loader 处理了，就不会继续遍历了，打包速度更快。
   3. 使用 Include/Exclude 排涂或只检测葉些文件，处理的文件更少，速度更快。
   4. 便用 Cache 对 eslint 和 babel 处理的结果进行緩存，让第二次打包速度更快。
   5. 使用 Thead 多进程处理 eslint 和 babel 任务，速庭更快。（需要注意的是，进程启动通信都有开销的，要在比较多代码处理时便用才有效果）
3. 减少代码体积
   1. 便用 Tree Shaking 剔除了没有使用的多余代码，让代码体积更小，
   2. 使用 Rbabel/plugin-transforw-runtine 擂件对 babel 进行处理，让辅助代码从中引入，而不是每个文件都生成辅助代码，从而体积更小。
   3. 便用 Image Mnintzer 对项目中图片进行压缩，体积更小，请求通度更快。（嘉要注意的是，如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。
4. 优化代码运行性能
   1. 使用 Code spltt 对代码进行分割成多个 js 文件，从而便单个文件体积更小，并行加载 js 速度更快。并通过 impont 动态导入语法进行按需加载，从而达到需要使用时才加载该资源，不用时不加载资源。
   2. 使用 Preload / prefetch 对代码进行提前加载，等未来需要便用时就能直接便用，从而用户体验更好。
   3. 使用 Network Cache 能对编出资源文件进行更好的命名，将来好做緶存，从而用户体验更好。
   4. 使用 Core-js 对 js 进行城容性处理，让我们代码能运行在低版本浏览器。 5.使用 PwA 能让代码商线也能访问，从而提升用户体验
