1. 阐述 vue-router 中路由保护策略
2. 描述具体实现方式
3. 简单说一下它们是怎么生效的

回答范例：

1.  vue-router 中保护路由安全通常使用导航守卫来做，通过设置路由导航钩子函数的方式添加守卫函数，在里面判断用户的登录状态和权限，从而达到保护指定路由的目的。
2.  具体实现有几个层级：全局前置守卫 beforeEach、路由独享守卫 beforeEnter 或组件内守卫 beforeRouteEnter。以全局守卫为例来说，可以使用 router.beforeEach((to, from,next)=>{}）方式设置守卫，每次路由导航时，都会执行该守卫，从而检查当前用户是否可以继续导航，通过给 next 函数传递多种参数达到不同的目的，比如如果禁止用户继续导航可以传递 next(false)，正常放行可以不传递参数，传递 path 字符串可以重定向到一个新的地址等等。
3.  这些钩子函数之所以能够生效，也和 vue-router 工作方式有关，像 beforeEach 只是注册一个 hook 当路由发生变化，router 准备导航之前会批量执行这些 hooks，并且把目标路由 to， 当前路由 from，以及后续处理函数 next 传递给我们设置的 hook。

# vue-router 简介

某种模式匹配的路径，映射到同个组件。

# vue-router 原理

更新视图但不重新请求页面。

## 前端路由

直接找到与地址相匹配的组件或者对象，并将其渲染出来

改变地址而不向服务器发送请求有三种方式
浏览器：hash history
非浏览器 node 环境： abstract（非 browser）

### hash

```javascript
http://www.xxx.com/#/login
```

'#'hash 后面的变化，并不会导致浏览器向服务端发出请求，每次 hash 值变化，还会触发 hashchange 这个事件，通过这个事件，我们就知道 hash 值发生了哪些变化，然后我们便可以通过监听 hashchange 来实现更新页面部分内容的操作

```javascript
function matchAndUpdate() {
  // todo 匹配 hash 做 dom 更新操作
}

window.addEventListener("hashchange", matchAndUpdate);
```

### history

pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求

单页面的 url 不会多出'#'，会变得更加美观。但因为没有'#'号，所以当用户刷新页面之类的操作，浏览器还是会给服务器发送请求，为了避免出现这种情况，所以要服务端进行支持，需要把所有路由都重定向到根页面。

### HashHistory

替换路由

#### HashHistory.push()

**HashHistory.push() **将新路由添加到浏览器访问历史的栈顶

```javascript
1 $router.push() //调用方法

2 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（添加到栈顶）（window.location.hash= XXX）

3 History.transitionTo() //监测更新，更新则调用History.updateRoute()

4 History.updateRoute() //更新路由

5 {app._route= route} //替换当前app路由

6 vm.render() //更新视图

```

#### HashHistory.replace()

并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由

```javascript
replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {
  this.transitionTo(location, route => {
    replaceHash(route.fullPath)
    onComplete && onComplete(route)
  }, onAbort)
}

function replaceHash (path) {
  const i = window.location.href.indexOf('#')
  window.location.replace(
    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path
  )
}
```

### HTML5History

HTML5History.pushState()和 HTML5History.replaceState()

在 HTML5History 中添加对修改浏览器地址栏 URL 的监听是直接在构造函数中执行的，对 HTML5History 的 popstate 事件进行监听：

```javascript
window.addEventListener("popstate", handleRoutingEvent);
this.listeners.push(() => {
  window.removeEventListener("popstate", handleRoutingEvent);
});
```

1.  什么是 Router，以及 Router 发展的历史。
    路由的概念，是伴随 SPA 出现的。在此之前，页面的跳转是通过服务器端进行控制的；

        传统的页面的跳转，是通过前端向后台发送请求
        后台通过模板引擎的渲染，将一个新的 html 界面
        比如页面跳转时：
        	form 表单的提交；
        	a标签的默认属性；
        	js 调用 location.href，给其赋值；
        	H5: history 的 go / forward / back -- // history.push / replace?

在 SPA（即只有一个 html ）的出现后，前端可以自由控制组件的渲染，来模拟页面的跳转。

    页面是怎么发生跳转，向服务端请求的呢？-一浏览器劫持。
    在讲这部分内容前，我们先来说一下，hash 路由和 history 路由的区别
    SPA的方法，需要拦截请求；
    	hash 路由，当我的hash
    	history 的 go / forward / back 的时候，我的浏览器的地址，是发生了改变的，

总结：

    后端路由是根据 url 访问相关的 controller 进行数据资源和模板引擎的拼接，返回前端；
    前端路由是通过 js根据 url 返回对应的组件加载。
    所以，前端的路由包含两个部分：
    	url 的处理
    	组件加载

# vue-router 钩子

导航被触发。

在失活的组件里调用 beforeRouteLeave 守卫。

调用全局的 beforeEach 守卫。

在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。

在路由配置里调用 before Enter。

解析异步路由组件。

在被激活的组件里调用 beforeRouteEnter。

调用全局的 beforeResolve 守卫(2.5+)。

导航被确认。

调用全局的 afterEach 钩子。

触发 DOM 更新。

调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建如组件实例

会作为回调函数的参数传入。
