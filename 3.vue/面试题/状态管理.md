# 状态管理 vuex

1. vuex 是 vue 专用的状态管理库。它以全局方式集中管理应用的状态，并且可以保证状态变更的可预测性。
2. vuex 主要解决的问题是多组件之间状态共享的问题，利用各种组件通信方式，我们虽然能够做到状态共享，
   但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，也会使程序逻辑变得复杂。
   vuex 通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状
   态，响应式的数据也能够保证简洁的单向数据流动，我们的代码将变得更结构化且易维护。
3. vuex 并非必须的，它帮我们管理共享状态，但却带来更多的概念和框架。如果我们不打算开发大型单页应用
   或者我们的应用并没有大量全局的状态需要维护，完全没有使用 vuex 的必要。一个简单的 store 模式就足够
   了。反之，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：Flux 架构就像眼
   镜：您自会知道什么时候需要它。
4. 我在使用 vuex 过程中有如下理解：首先是对核心概念的理解和运用，将全局状态放入 state 对象中，它本身一
   棵状态树，组件中使用 store 实例的 state 访问这些状态；然后有配套的 mutation 方法修改这些状态，并且只能
   用 mutation 修改状态，在组件中调用 commit 方法提交 mutation；如果应用中有异步操作或者复杂逻辑组合，
   我们需要编写 action，执行结束如果有状态修改仍然需要提交 mutation，组件中调用这些 action 使用 dispatch
   方法派发。最后是模块化，通过 modules 选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名
   称，如果子模块有设置 namespace，那么在提交 mutation 和派发 action 时还需要额外的命名空间前缀。
5. vuex 在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是借用了 vue 的数据响应化特性实现
   的，它会利用 Vue 将 state 作为 data 对其进行响应化处理，从而使得这些状态发生变化时，能够导致组件重新
   渲染。

每一个 Vuex 里面有一个全局的 Store，包含应用中的状态。单一的，一个应用仅会包含一个 Store 实例

```javascript
const app = new Vue({
  el: "#app",
  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件
  store,
  components: { Counter },
  template: `
    <div class="app">
      <counter></counter>
    </div>
  `,
});
const Counter = {
  template: `<div>{{ count }}</div>`,
  computed: {
    count() {
      return this.$store.state.count;
    },
  },
};
```

Mutation：Vuex 通过提交 mutation 的方式修改 store，有一个事件类型和一个回调函数 同步事务

```javascript
const store = new Vuex.Store({
    state: {
        count: 1
    },
    mutations: {
        increment(state) {
            state.count++
        }
    }
})

触发：store.commit('increment')
```

Action：异步，里面执行异步操作，完事之后通过 store.commit('increment')来触发 mutation
一个 Action 中可以触发多个 mutation 类似一个灵活好用的中间件

```javascript
	actions: {
		// get token
		getToken({ commit, dispatch }, params) {
			return client.post('/Account/GetToken', { data: params }).then((data) => {
				if (data.issuccess) {
					commit('GET_TOKEN', data)
				}
				return data
			})
        },
    }
```

声明 Store 类，挂载 Store
Store 具体实现：
创建响应式的 state，保存 mountations、actions 和 getters
实现 commit 根据用户传入 type 执行对应的 mountation
实现 dispatch 根据用户传入 type 执行对应 action，同时传递上下文
实现 getters，按照 getters 定义对 state 做派生

Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过 Mutation 来修改 State 的数据。最后，根据 State 的变化，渲染到视图上。

### State

单一状态树 ---- 对应 Vue 中的 data

### Getters

需要从 store 中的 state 中派生出一些状态--- 对应 Vue 中的 computed

### Mutations

更改 Vuex 的 store 中的状态唯一方法是提交 mutation。

遵守 Vue 的响应规则：

1、最好提前在 store 中初始化好所有所需属性
2、当需要再对象上添加新属性时，
使用 Vue.set(obj, 'newProp', 123) 或者
以新对象替换老对象，例如利用对象展开运算符

```javascript
state.obj = { ...state.obj, newProp: 123 };
```

Mutation 必须是同步函数
Vuex 可以通过 devtool 监听数据变化。
每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。如果 mutation 中异步函数中的回调是不可追踪的。devtools 不知道什么时候回调函数实际上被调用。

### Actions

提交的是 mutation，而不是直接变更状态
可以包含任意异步操作

## Vuex 原理

Vuex 是一个专门为 Vue.js 应用程序开发的状态管理模式。

Vue 的插件

每一个 Vue 的插件都有一个 install 方法。

## vuex 的 store 是如何挂载注入到组件中呢？

1、在 Vue 项目中安装使用 Vuex

```javascript
import Vuex from "vuex";
Vue.use(vuex); // vue的插件机制
```

2、利用 Vue 的插件机制，使用 Vuex.use(vuex),会调用 Vuex 的 install 方法，装载 Vuex

```javascript
// src/store.js
export function install(_Vue) {
  if (Vue && _Vue === Vue) {
    return;
  }
  Vue = _Vue;
  applyMixin(Vue);
}
```

3、applyMixin 方法使用 vue 混入机制，vue 的生命周期 beforeCreate 钩子函数前混入 vuexInit 方法

```javascript
// src/mixins.js
// 对应applyMixin方法
export default function (Vue) {
  const version = Number(Vue.version.split(".")[0]);

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit });
  } else {
    const _init = Vue.prototype._init;
    Vue.prototype._init = function (options = {}) {
      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */
  // vuexInit方法实现了store注入vue组件实例 并注册了vuex store的引用属性$store
  function vuexInit() {
    const options = this.$options;
    // store injection
    if (options.store) {
      this.$store =
        typeof options.store === "function" ? options.store() : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
}
```

## vuex 的 state 和 getters 是如何映射到各个组件实例中响应式更新状态呢？

store 实现的源码在 src/store.js resetStoreVM 核心方法

```javascript
// src/store.js
function resetStoreVM(store, state, hot) {
  // 省略无关代码
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state,
    },
    computed,
  });
}
```

Vuex 的 state 状态是响应式，借助 Vue 的 data 响应式，将 state 存入 Vue 实例组件的 data 中。
Vuex 的 getters 则是借助于 Vue 的计算属性 computed 实现数据实时监听。

使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持

### Vuex 和 Vue

更改数据 mutations->methods
获取数据 getters -> computed
数据 state->data

通过 dispatch 可以触发 actions 中的方法
actions 中的 commit 可以触发 mutations 中的方法。

mutation 和 action 就相当于 vue 中的 method

# 面试

面试官：vuex 什么时候进行的初始化 - beforeCreate
面试题：vuex 自己定义了告警，为啥不用 console.assert? - throw Error 灵活控制执行 不堵塞
