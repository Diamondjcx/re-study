#####函数的扩展

- 函数参数的默认值

```
function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello
```

```
function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {
  console.log(method);
}

fetch('http://example.com')
```

```
练习
// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
```

- rest 参数

```
function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。
```

- 严格模式
- 只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
- 箭头函数
- 基本用法

```
var f = v => v;

// 等同于
var f = function (v) {
 return v;
};
```

- 箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回

```
var sum = (num1, num2) => { return num1 + num2; }
```

- 大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。

```
// 报错
 let getTempItem = id => { id: id, name: "Temp" };

 // 不报错
 let getTempItem = id => ({ id: id, name: "Temp" });
```

- 注意点

  - （1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。

  ```js
  function foo() {
    setTimeout(() => {
      console.log('id:', this.id)
    }, 100)
  }
  ```

- （2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。

- （3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

- （4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
