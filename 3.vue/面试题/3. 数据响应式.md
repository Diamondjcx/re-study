# Object.defineProperty VS Proxy

**(1)** Object.defineProperty 只能劫持对象的属性，而 Proxy 是直接代理对象

由于 Object.defineProperty 只能对属性进行劫持，需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。而 Proxy 是直接代理对象，不需要遍历操作

Proxy 是在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，可以对外界的访问进行过滤和改写。

**(2)** 当对数组进行操作(push\shift\splice)，会触发对应的方法名称和 length 变化，可以借此进行操作

Proxy 不需要那么多 hack，无压力监听数组的变化

Proxy 通过 set(target, propKey, value, receiver) 拦截对象属性的设置，是可以拦截到对象的新增属性的

**(3)** Proxy 支持 13 种拦截操作，这是 defineProperty 所不具有的。

**(4)** 新标准性能红利

Proxy 作为新标准，从长远来看，JS 引擎会继续优化 Proxy，但 getter 和 setter 基本不会再有针对性优化。

# 总结

1. Object.defineProperty 并非不能监控数组下标的变化，Vue2.x 中无法通过数组索引来实现响应式数据的自动更新是 Vue 本身的设计导致的，不是 defineProperty 的锅。
2. Object.defineProperty 和 Proxy 本质差别是，defineProperty 只能对属性进行劫持，所以出现了需要递归遍历，新增属性需要手动 Observe 的问题。
3. Proxy 作为新标准，浏览器厂商势必会对其进行持续优化，但它的兼容性也是块硬伤，并且目前还没有完整的 polyfill 方案。

# vue 响应式理解？

答题思路

1. what
2. why
3. 带来了什么好处？
4. vue 的响应式是怎么实现的？ 有哪些优缺点？
5. vue3 中的响应式的新变化

回答范例：

1.  所谓数据响应式就是能够使数据变化可以被检测并对这种变化做出响应的机制
2.  mvvm 框架中要解决的一个核心问题就是连接数据层和视图层，通过数据驱动应用数据变化，视图更新，要做到这点就需要对数据做响应式处理，这样一旦数据发生变化可以立即做出更新处理
3.  vue 为例，通过数据响应式加上虚拟 DOM 和 patch 算法，可以使我们只需要操作数据，完全不用接触繁琐的 dom 操作，从而大大提升开发效率，降低开发难度。
4.  vue2 中的数据响应式会根据数据类型来做不同的处理，如果是对象则采用 Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应；如果是数组则通过覆盖该数组原型的方法，扩展它的 7 个变更方法，
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'使这些方法可以额外的做更新通知，从而作出响应。这种机制很好的解决了数组响应化的问题，但是在实际使用中也存在一些缺点；比如初始化时的递归遍历会造成性能损失；新增或删除属性时需要用户使用 Vue.set/delete 这样特殊的 api 才能生效；对于 es6 中新产生的 Map、Set 这些数据结果不支持等问题

    > Object.defineProperty()这个 api 没办法监听数组长度的变化，也就没办法监听数组的新增
    > Vue 无法检测通过数组索引改变数组的操作，不是 api 的原因，而是认为性能消耗与带来的用户体验不成正比，数组项可能会很大，1000 条 10000 条

         //   通过下标获取某个元素和修改某个元素的值，可以触发getter和setter

         //   数组的push方法，数组下标可以看做对象的key，增加了下索引为3的元素。但是并未对新的下标进行observe，不会触发

         //   数组的unshift方法：将原来索引为0、1、2、3的值取出来，然后重新赋值，所以触发了很多次getter和setter

         //   数组的pop方法：移除的时候会触发getter，再次修改或者取值，并不会触发

         //   总结：
         //     通过索引访问或设置对应元素的值时，可以触发getter和setter方法
         //     通过push或unshift会增加索引，对于新增加的属性，需要再手动初始化才能被observe
         //     通过 pop 或 shift 删除元素，会删除并更新索引，也会触发 setter 和 getter 方法

         //   vue对数组的observe进行了重写，hack


         // Object.defineProperty 为什么不可以监听数组的length，因为length属性本身是不可配置的，configurable为false
         // 所以造成push pop这种会修改原数组length的值无法被监听到

         // Proxy：  代理虚拟化的对象。它通常用作代理的存储后端。根据目标验证关于
         // Array.length 就是不可配置的属性，故Proxy可以监听原数组中长度的变化。

5.  为了解决这些问题，vue3 重新编写了这一部分的实现；利用 es6 的 Proxy 机制代理要响应化的数据，有很多好处：编程体验一致，不需要使用特殊 api，初始化性能和内存消耗都得到了大幅改善；另外由于响应化的实现代码抽取为独立的 reactivity 包，使得我们可以更灵活的使用它，不需要引入 vue 都可以体验
