### 聊一聊你对于性能优化的理解和经验

#### 一、从浏览器输入一个 url 到展示页面中间经历了哪些过程？

- 输入 url

```js
// http://www.123.cm - http协议
// 面试题 http&TCP-(TCP/IP)=>计算机网络
// 1. http - 应用层 ｜ TCP -传输层
// 2. 关联性：http基于TCP实现连接建立=》追问：TCP连接特性（请求、发送、断开）=》debug

//http版本概念
// 面试题：http1.0 1.1 2.0 区别
// =》keep-alive 配置实现长链接 =》不反复重建TCP连接=》节约性能
// =》多条并发服用同一条通路=》chrome限制了最大TCP连接数量6=》复用通路，无兵法限制
// =》查询压力变大

分析：
// 输入：max参数
// 存储：taskque
// 提供能力：执行-run ｜ 创建任务 - createTask
// 唯一性系统=》单例模式
class LimitPromise {
    constructor(max){
        // 异步并发的并发上线
        this._max = max || 6
        // 当前正在执行任务数量
        this._count = 0;
        // 等待执行的任务队列
        this._taskQueue = [];
    }


    run(caller) {
        // 主入口
        // 输入：外部传入要添加的请求
        // 输出：队列处理的promise
        return new Promise((resolve,reject)=> {
            // 创建一个处理任务
            const task = this._createTask(caller,resolve,reject)

            // 当前任务数量是否达到上限
            if (this._count >= this._max) {
                this._taskQueue.push(task)
            } else {
                task();
            }
        })
    }

    _createTask(caller, resolve, reject) {
        return () => {
            caller().then(res=> {
                resolve(res)
            }).catch(err=> {
                reject(err)
            }).finally(() => {
                this.count--
                if(this._taskQueue.length) {
                    // 完成任务清出
                    const task = this._taskQueue.shift();
                    task()

                }
            })
            this._count++
        }
    }

    // 单例模式
    static getInstance(max) {
        if(!this.instance) {
            this.instance = new LimiPromise(max);
        }
        return this.instance
    }
}


```

2. 域名解析

```js
// DNS 缓存 - 浏览器、系统（host文件）、路由器缓存、ISP、根域名
// 优化：CDN - content deliver network - 分配资源 （请求资源最少 距离最近）
```

3. 浏览器渲染

```js
// 面试题
// 主线渲染的流程：DOM + CSSOM => renderTree + js (单线程)=> layout => paint

// repaint & reflow
// =》减少重绘、避免重排
// display：none =》 refolw
// visibility：hidden =》repaint
```

4. 代码层面 - GC 垃圾回收
   内存分配=》内存使用=》内存回收

```js
// 1. 多层级-宜平不宜深；循环饮用记得销毁
// 2. 未触达 mark & sweep
```

### 面试

谈谈对于前端优化的理解？
如果你是这个项目的负责人，你会如何做前端优化设计？

答：

1. 网络提速
   减少网络请求 ｜ 使用 CDN
   1. 减少网络请求为什么可以优化性能？哪部分损耗时间？（网络请求分为很多步骤，每一步都需要时间，请求多了必然损耗时间）具体原因
      http & https =》 TCP 连接 ｜ 加密处理 （http 和 tcp 区别 tcp 和 udp 区别 非对称加密 加密需要时间）
      http1._ & http2._ =》复用 ｜ 帧 （1.0：tcp 通路复用 keep-alive ｜ 帧发送 不受最大数量限制）
   2. CDN 加速原理
      静态加速 & 动态加速 （ 缓存静态文件 js css 图片 上海、深圳 地理位置较近的 节点缓存静态文件 & 帮助减轻源站的负载 同时访问）
2. 图片加载
   压缩｜懒加载｜雪碧图｜图片类型优化

   1. 图片类型有哪些？如何根据类型进行优化？
      JPG - 有损且压缩 =》底图 banner （体积小、加载快，适合标题背景、banner、轮播、模糊不支持透明）
      PNG - 无损压缩 =》细节 （质量很高、体积大 色彩 大 logo 复杂图）
      SVG - 体积小 =》icon （兼容性好，渲染成本高，节点构成，不失真

   2. 图片加载优化
      utl 处理 ✖️2（列表 ✖️3（详情 ✖️4
      弱网、强网
      data-src 和 src 的切换实现突破懒加载

3. 打包优化
   分包｜压缩｜抽离公共模块｜ tree shaking
   1. webpack 工作原理
      万物皆模块 - 将事物依赖以模块的形式存在 = 》复用
      按需加载 - 代码分割、按需加载、定制产出
4. 内容加载
   异步加载 ｜ 骨架屏

系统性思维 =》体系化知识脉络

面试官真正想听到的：

1. 页面加载上
   资源加载 ｜ 代码执行 ｜ 数据接口 ｜ 绘制渲染
2. 平台资源性能上
   纯前端 ｜ 跨平台｜ hybrid ｜ 小程序
3. 流程优化设计
   简化：串联（多个代码仓库、业务仓库、sdk 仓库）｜调试加速 ｜性能逻辑
   前置：逻辑前置 ｜ 配置前置
   拆分：细粒度拆分 ｜ 模块架构设计拆分
