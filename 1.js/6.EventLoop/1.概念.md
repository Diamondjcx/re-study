##### 起始

###### JavaScript 的诞生

- 最初的目的：校验表单需要上传给后台，假如用户名或密码不正确，重新填写之后还要多次提交
  有了这门脚本语言就不用多次提交，浏览器可以校验表单填写是否正确，再进行提交
- JavaScript 是为了服务浏览器上的⽹⻚推出的，浏览器选择调度 JavaScript 脚本执⾏

###### 事件循环

- 事件循环文档
  - JavaScript 标准文档 无描述
  - HTML 标准文档 https://html.spec.whatwg.org/multipage/webappapis.html#event-loops
- 定义 JavaScript 是被事件循环的，是 user agent 的行为,根据标准中对事件循环的定义描述，我们可以发现事件循环本质上是 user agent (如浏览器端) ⽤于协调⽤户交互（⿏标、键盘）、脚本（如 JavaScript）、渲染（如 HTML DOM、CSS 样式）、⽹络等⾏为的⼀个机制。
- 了解到这个定义之后，我们就能够清楚的明⽩，与其说是 JavaScript 提供了事件循环，不如说是嵌⼊ JavaScript 的 useragent 需要通过事件循环来与多种事件源交互。
- 要排队，不要一窝蜂的涌上来，放在队列中，固定队列，让 eventloop 有序执行。

###### 队列

各种浏览器事件同时触发时，肯定有⼀个先来后到的排队问题。决定这些事件如何排队触发的机制，就是事件循环。这个排队⾏为以 JavaScript 开发者的⻆度来看，
主要是分成两个队列：

- ⼀个是 JavaScript 外部的队列。外部的队列主要是浏览器协调的各类事件的队列，标准⽂件中称之为 Task Queue。下⽂中为了⽅便理解统⼀称为外部队列。
- 另⼀个是 JavaScript 内部的队列。这部分主要是 JavaScript 内部执⾏的任务队列，标准中称之为 Microtask Queue。下⽂中为了⽅便理解统⼀称为内部队列。值得注意的是，虽然为了好理解我们管这个叫队列 (Queue)，但是本质上是有序集合 (Set)，因为传统的队列都是先进先出（FIFO）的，⽽这⾥的队列则不然，排到最前⾯但是没有满⾜条件也是不会执⾏的（⽐如外部队列⾥只有⼀个 setTimeout 的定时任务，但是时间还没有到，没有满⾜条件也不会把他出列来执⾏）。
- 外部队列（Task Queue [3]），顾名思义就是 JavaScript 外部的事件的队列，这⾥我们可以先列举⼀下浏览器中这些外部事件源（TaskSource），他们主要有：
  - DOM 操作 (⻚⾯渲染)
  - ⽤户交互 (⿏标、键盘)
  - ⽹络请求 (Ajax 等)
  - History API 操作
  - 定时器 (setTimeout 等) [4]
    `没有处理时间这些问题，系统调用，权限较高，普通的沙箱，不能调用操作系统的时间，想知道时间，必须是浏览器给时间，调用的是浏览器的api，所以定时也是浏览器帮忙定时的 `
    可以观察到，这些外部的事件源可能很多，为了⽅便浏览器⼚商优化，
    HTML 标准中明确指出⼀个事件循环由⼀个或多个外部队列，⽽每⼀个
    外部事件源都有⼀个对应的外部队列。不同事件源的队列可以有不同的
    优先级（例如在⽹络事件和⽤户交互之间，浏览器可以优先处理⿏标⾏
    为，从⽽让⽤户感觉更加流程）。
- 内部队列（Microtask Queue），即 JavaScript 语⾔内部的事件队列，
  在 HTML 标准中，并没有明确规定这个队列的事件源，通常认为有以下
  ⼏种：
  - Promise 的成功 (.then) 与失败 (.catch)
  - MutationObserver
  - Object.observe (已废弃)

###### 执行顺序

- 1. ⼀次外部事件
- 所有内部事件
- HTML 渲染
- 回到到 1

###### node

- 浏览端是将 JavaScript 集成到 HTML 的事件循环之中，那么 Node.js 则是将 JavaScript 集成到 libuv 的 I/O 循环之，js 是被 eventloop 的

###### 浏览器端和 node 端的差异

- 1. 事件循环的过程没有 HTML 渲染。只剩下了外部队列和内部队列这两个部分。
- 2. 外部队列的事件源不同。Node.js 端没有了⿏标等外设但是新增了⽂件等 IO。
- 3. 内部队列的事件仅剩下 Promise 的 then 和 catch。
  - ⾄于内在的差异，有⼀个很重要的地⽅是 Node.js （libuv）在最初设计的时候是允许执⾏多次外部的事件再切换到内部队列的，⽽浏览器端⼀次事件循环只允许执⾏⼀次外部事件。node 11 之前是这样的

```js
setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(function () {
    console.log('promise1')
  })
})
setTimeout(() => {
  console.log('timer2')
  Promise.resolve().then(function () {
    console.log('promise2')
  })
})
```

究其原因，主要是因为浏览器端有外部队列⼀次事件循环只能执⾏⼀个的限制，⽽在 Node.js 中则放开了这个限制，允许外部队列中所有任务都执⾏完再切换到内部队列。所以他们的情况对应为：

• 浏览器端
i. 外部队列：代码执⾏，两个 timeout 加⼊外部队列
ii. 内部队列：空
iii. 外部队列：第⼀个 timeout 执⾏，promise 加⼊内部队列
内部队列：执⾏第⼀个 promise
iv. 外部队列：第⼆个 timeout 执⾏，promise 加⼊内部队列
v. 内部队列：执⾏第⼆个 promise
timer1 promise1 timer2 promise2

• Node.js 服务端
i. 外部队列：代码执⾏，两个 timeout 加⼊外部队列
ii. 内部队列：空
iii. 外部队列：两个 timeout 都执⾏完
iv. 内部队列：两个 promise 都执⾏完 timer1 timer2 promise1 promise2

修复缘由

- 因为很多第三方库都是同时支持浏览器端和 node 端，如果不保持统一，会造成不同的效果，所以在 node12 就修复了这个问题，保持和浏览器统一
